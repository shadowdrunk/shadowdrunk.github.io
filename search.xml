<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CF1934 D2. XOR Break — Game Version题解</title>
    <url>/2025/08/22/CF1934%20D2-XOR-Break-%E2%80%94-Game-Version%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D2-XOR-Break-—-Game-Version"><a href="#D2-XOR-Break-—-Game-Version" class="headerlink" title="D2. XOR Break — Game Version"></a><a href="https://codeforces.com/problemset/problem/1934/D2">D2. XOR Break — Game Version</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个初始数字n，我们要和对手进行博弈，我们可以选择先后手，我们与对手进行的游戏是这样的，当前数字初始为p，当前回合的选手需要构造两个数字p1，p2，满足（0 &lt; p1 &lt; p, 0 &lt; p2 &lt; p, p1 ^ p2 &#x3D;&#x3D; p)，若无法构造出p1，p2则当前回合玩家输，然后另一个人挑选其中任意一个数作为当前数字p，并开始它的回合。我们最多可以进行63次回合，需要保证必胜。初始数字n &lt; 1e18。交互题，系统给出对面的操作。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们可以发现一个关键的边界条件，当初始数字中为1的位为1时我们无法对其进行拆解，此时是必败态。我们考虑如何让对手到达这个状态或是这个状态由和转移过来。一个简单的必胜态是有两位数的情况，此时我们拆成两个1位为1的位的数则必胜。继续推广我们发现通过构造所有的为1的位为偶数时都是必胜态，奇数都是必败态，具体证明如下，对于一个偶数个位为1的数我们一定可以把其拆成两个为1的位为奇数的数，而对于为1的位为偶数的数我们无论怎么拆都是一奇数位为1，一个偶数位为1，所以我们只要继续挑选那个偶数位1的数进行拆分就可继续必胜。具体的拆分为了减少对面新增的1的位，我们直接把最高位1拆走，剩余的构成另外一个数即可，在题目要求下易证操作回合小于等于63。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcnt</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">63</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">getcnt</span>(n);</span><br><span class="line">    ll p1 = n;</span><br><span class="line">    ll p2 = n;</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> op = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="number">0</span> &amp;&amp; p2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        op += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getcnt</span>(p1) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(p1, p2);</span><br><span class="line">        ll out1 = (<span class="number">1LL</span> &lt;&lt; std::__lg(p1));</span><br><span class="line">        ll out2 = (p1 ^ out1);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; out1 &lt;&lt; space &lt;&lt; out2 &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>博弈论</tag>
        <tag>cf2400</tag>
        <tag>位运算</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1981D D. Turtle and Multiplication 题解</title>
    <url>/2025/08/21/CF1981D-D-Turtle-and-Multiplication-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D-Turtle-and-Multiplication"><a href="#D-Turtle-and-Multiplication" class="headerlink" title="D. Turtle and Multiplication"></a><a href="https://codeforces.com/contest/1981/problem/D">D. Turtle and Multiplication</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个数字n，我们需要构造一个长度为n的数组，满足以下条件，数组中的所有元素属于[1, 3e5]，数组中没有两个相邻的元素的乘积相同，数组中不同的数的种类是长度为n下所有合法数组中最小的。输出任意一个符合条件的解。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先考虑如何在保证没有相邻元素的乘积相同的同时使得数组中不同种类的数的个数最小，我们发现我们选择所有不同的素数来构成数组一定是最优的，因为素数的性质保证了只要相邻两个元素的组成不同乘积就不同，不会出现2 * 6 &#x3D;&#x3D; 3 * 4这样的情况。x个数组可以组成 （x * (x + 1) ) &#x2F; 2种不同的组合。我们发现如果从图论的角度抽象这个问题，把不同的两两组合看作两个节点之间的边，那么问题就变成了从这张图中找出一个长度为n的欧拉路，注意到当need（需要的最少素数个数）为奇数时，图一定存在欧拉回路，need为偶数时图中不存在走完所有边的欧拉路，此时我们最少要删除（need - 2）&#x2F; 2条边才可以得到一个可以走完所有边的欧拉路，这也就是need个素数时可以产生的最大贡献。</p>
<p>​	通过素数筛法我们发现3e5范围内的素数是够用的，我们直接全部用素数构造数组即可，找到最小需要的素数数量，然后构建一个这几个素数的完全图，如果need为偶数时3 - 4 ，5 - 6， 7 - 8…这些边去掉，最后就可以保证欧拉路的存在。然后我们找出从1节点开始的欧拉路即可，此时一定可以包含图中所有边，我们输出前n - 1条边组成的节点即可得到长度为n的数组，且一定满足数组的需求定义。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; minp, primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    minp.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    primes.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            minp[i] = i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            minp[i * p] = p;</span><br><span class="line">            <span class="keyword">if</span> (p == minp[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e7</span>;  <span class="comment">//无向边需要开两倍</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> nex;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].from = u;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].nex = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> need = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2e3</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> all = (i * (<span class="number">1</span> + i)) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            all -= (i - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(all + <span class="number">1</span> &gt;= n)&#123;</span><br><span class="line">            need = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> all = (need * (<span class="number">1</span> + need)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        all -= (need - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(<span class="number">1</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= need; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= need; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">1</span> &amp;&amp; i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; j == i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            edge.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            <span class="built_in">add</span>(i, j);</span><br><span class="line">            <span class="built_in">add</span>(j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">use</span><span class="params">(cnt + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> node) -&gt; <span class="type">void</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now = head[node]; now &gt; <span class="number">0</span>; now = head[node])&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(use[now])&#123;</span><br><span class="line">                head[node] = e[now].nex;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            use[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">                use[now ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            head[node] = e[now].nex;    <span class="comment">//删去遍历过的点</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dfs</span>(e[now].to);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ind = (t == <span class="number">1</span> ? now / <span class="number">2</span> : now - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span> &amp;&amp; now % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(ind);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(-ind);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(ind); <span class="comment">//注意对于有向图我们这里实际是找到的逆的路径，所以不用-ind</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(edge[ans[i]].ff);</span><br><span class="line">            res.<span class="built_in">push_back</span>(edge[ans[i]].ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(edge[-ans[i]].ss);</span><br><span class="line">            res.<span class="built_in">push_back</span>(edge[-ans[i]].ff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; primes[res[i]] &lt;&lt; sendl[i == n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= need; i++)</span><br><span class="line">        head[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2400</tag>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>欧拉路/回路</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1969E E. Unique Array题解</title>
    <url>/2025/08/23/CF1969E-E-Unique-Array%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Unique-Array"><a href="#E-Unique-Array" class="headerlink" title="E. Unique Array"></a><a href="https://codeforces.com/contest/1969/problem/E">E. Unique Array</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的数组，一个子段被称为独特的，当且仅当子段中存在一个元素只出现了一次。我们可以进行一种操作选择数组中的任意一个元素将其替换成任意数字。我们需要输出我们最少需要进行几次操作可以使得数组中的所有子段都是独特子段。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们容易想到一个O(n ^ 2 * lgn)的解法我们可以暴力的处理除所有不好的子段，根据我们操作的性质容易发现我们只要对子段中任意一个元素进行操作我们就一定可以使得包含这个元素的子段独特，于是问题转换成了一些区间，我们要选择最少数量的点，满足每个区间中至少包含一个节点。这是一个经典的贪心问题，我们直接按左端点或右端点排序，顺着贪心的取最边界的点即可。</p>
<p>​	我们发现实际上有效的区间数量实际上是不超过n个的，因为所有完全覆盖了某个区间的区间都是没有意义的，于是我们可以考虑处理出每个左端点对应的最小的不独特的区间，考虑如何处理出这些区间。我们可以对每个位置的数处理出其下一个相同的数的位置，我们枚举每个左端点，初始将所有的数的第一个进行区间[x, nxt[x] - 1] + 1的操作，这意味着从x到nxt[x] - 1被我们标记了，是不可以选择的右端点，因为其是独特的，我们找到（i，n）的最小的右端点，满足其元素为0即可，我们可以通过线段树维护最小值和最小值的下标来实现。处理出所有的区间后按照之前所述的贪心策略求最小点即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T pos;</span><br><span class="line">        T minn;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.minn = std::<span class="built_in">min</span>(a.minn, b.minn);</span><br><span class="line">        res.pos = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.minn == res.minn)</span><br><span class="line">            res.pos = std::<span class="built_in">min</span>(res.pos, a.pos);</span><br><span class="line">        <span class="keyword">if</span>(b.minn == res.minn)</span><br><span class="line">            res.pos = std::<span class="built_in">min</span>(res.pos, b.pos);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].minn = <span class="number">0</span>;</span><br><span class="line">            tree[p].pos = pl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        p.minn += d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i];</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        nxt[i] = last[cur[i]];</span><br><span class="line">        last[cur[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(last[i] != n + <span class="number">1</span>)&#123;</span><br><span class="line">            seg.<span class="built_in">update</span>(last[i], nxt[last[i]] - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = seg.<span class="built_in">query</span>(i, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.minn == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;i, p.pos&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">update</span>(i, nxt[i] - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nxt[i] != n + <span class="number">1</span>)</span><br><span class="line">            seg.<span class="built_in">update</span>(nxt[i], nxt[nxt[i]] - <span class="number">1</span>, <span class="number">1</span>);            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.ff &lt;= ls)&#123;</span><br><span class="line">            ls = std::<span class="built_in">min</span>(ls, p.ss);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">        ls = p.ss;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2400</tag>
        <tag>数据结构</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2063F2 F2. Counting Is Not Fun (Hard Version)题解</title>
    <url>/2025/08/21/CF2063F2-F2-Counting-Is-Not-Fun-Hard-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F2-Counting-Is-Not-Fun-Hard-Version"><a href="#F2-Counting-Is-Not-Fun-Hard-Version" class="headerlink" title="F2. Counting Is Not Fun (Hard Version)"></a><a href="https://codeforces.com/contest/2063/problem/F2">F2. Counting Is Not Fun (Hard Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​   题目给我们一个数字n，代表一个有着n个好对的括号序列，一个好对（i, j) (i &lt; j) 满足s[i] &#x3D;&#x3D; ‘(‘, s[j] &#x3D;&#x3D; ‘)’同时去掉i，j两个字符，区间内剩余的子串是一个合法的平衡括号字符串，可以证明对于一个长度位2 * n的括号序列一定有n个好对。题目依次给出n个好对，我们需要计算出前i个好对确定的情况下有多少种符号要求的合法括号字符串（i从0到n）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	与easy版本不同的是hard版的数据到达了3e5，首先我们easy版计算长度为x的合法括号序列的复杂度我们就无法接受，考虑如何快速计算，这实际上就是卡特兰数，我们的平衡度总是大于等于0，最后等于0，相当于不穿过y &#x3D; x，走到（x &#x2F; 2， x &#x2F; 2），我们可以世界使用卡特兰数的组合数学公式来快速计算。</p>
<p>​	接着考虑如何计算每个前缀好对的可能的括号序列数，注意到easy版我们对每个都进行了重新计算，这实际上没有必要，因为我们新加入一个好对只会影响最小的覆盖其的好对，重新计算它的贡献，然后乘上新加入的好对的贡献即可。要知道最小覆盖其的好对我们可以使用一个线段树维护覆盖某个点的长度最小的对的序号即可，这实际上相当于线段树维护最小值。知道某个好对还没被覆盖的点的个数我们可以使用令一个线段树维护区间最小值和这个区间最小值的个数即可，考虑某个好对，覆盖其的好对一定不会计算到其中，之后其中的好对非区间最小值的一定被覆盖了，而区间最小值一定没有被覆盖。我们重新计算新加入好对及覆盖其的好对的贡献即可。</p>
<p>​	本题实际上有一个更为简单的实现，倒着求答案，看作删除一个好对，这相当于把删除的好对和最小覆盖其的好对合并到了一起，抽象成图论可以看作缩点，其覆盖的子好对顺着转移过去即可，使用并查集维护节点，同时维护某个好对覆盖的子对长度和即可简单实现计算。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>; <span class="comment">//注意这里要多开点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line">ll fact[N + <span class="number">1</span>],infact[N + <span class="number">1</span>];   <span class="comment">//  阶乘和阶乘的逆元</span></span><br><span class="line"><span class="comment">//取模版本快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll k, ll m)</span></span>&#123;   <span class="comment">//求a^k mod m</span></span><br><span class="line">    a %= m;</span><br><span class="line">    ll res = <span class="number">1</span> % m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * a % m;<span class="comment">//指数k为1的位乘上a^(1&lt;&lt;x)mod m</span></span><br><span class="line">        a = a * a % m;<span class="comment">//每一项是前一项的平方模m</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n = N)</span></span>&#123; <span class="comment">// 预处理阶乘取模的余数和阶乘取模余数的逆元</span></span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    infact[N] = <span class="built_in">qmi</span>(fact[N], mod - <span class="number">2</span>, mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        infact[i] = infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组合数A和C</span></span><br><span class="line"><span class="comment">//C(a, b) = !a / !(a - b) * !(b)    //a个里挑b个</span></span><br><span class="line"><span class="comment">//A(a, b) = !a / !(a - b)</span></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fact[a] * infact[a-b] % mod * infact[b] % mod;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> fact[a] * infact[a-b] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求逆元</span></span><br><span class="line"><span class="function">ll <span class="title">contary</span><span class="params">(ll now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmi</span>(now, mod - <span class="number">2</span>, mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力计算组合数C</span></span><br><span class="line"><span class="function">ll <span class="title">burteC</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; k || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) ret = ret * (m - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) ret = ret * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getCn</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">C</span>(<span class="number">2</span> * n, n) - <span class="built_in">C</span>(<span class="number">2</span> * n, n - <span class="number">1</span>) + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T minn;</span><br><span class="line">        T val;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.minn = std::<span class="built_in">min</span>(a.minn, b.minn);</span><br><span class="line">        <span class="keyword">if</span>(a.minn == res.minn)</span><br><span class="line">            res.val += a.val;</span><br><span class="line">        <span class="keyword">if</span>(b.minn == res.minn)</span><br><span class="line">            res.val += b.val;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = <span class="number">1</span>;</span><br><span class="line">            tree[p].minn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        p.minn += d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">0</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>((n + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>((n + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeInd</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T minind;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur[a.minind].ss - cur[a.minind].ff &lt;= cur[b.minind].ss - cur[b.minind].ff)</span><br><span class="line">            res = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res = b;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = a[pl];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[p.minind].ss - cur[p.minind].ff &gt;= cur[d].ss - cur[d].ff)</span><br><span class="line">            p.minind = d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[tag[p]].ss - cur[tag[p]].ff &gt;= cur[d].ss - cur[d].ff)</span><br><span class="line">            tag[p] = d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTreeInd</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTreeInd</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    cur.<span class="built_in">assign</span>(n + <span class="number">1</span>, std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;());</span><br><span class="line">    cur[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">2</span> * n + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line">    std::vector&lt;ll&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="built_in">getCn</span>(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> segid = <span class="built_in">SegmentTreeInd</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="built_in">getCn</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ll in = seg.<span class="built_in">query</span>(cur[i].ff, cur[i].ss).val;</span><br><span class="line">        ll need = (in - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        ans = ans * <span class="built_in">getCn</span>(need) % mod;</span><br><span class="line"></span><br><span class="line">        ll fa = segid.<span class="built_in">query</span>(cur[i].ff, cur[i].ff).minind;</span><br><span class="line">        </span><br><span class="line">        ll infa = seg.<span class="built_in">query</span>(cur[fa].ff, cur[fa].ss).val;</span><br><span class="line"></span><br><span class="line">        ll needfa = (infa - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        ll con = <span class="built_in">getCn</span>(needfa);</span><br><span class="line">        ans = ans * <span class="built_in">qmi</span>(con, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">update</span>(cur[i].ff, cur[i].ss, <span class="number">1</span>);</span><br><span class="line">        infa = seg.<span class="built_in">query</span>(cur[fa].ff, cur[fa].ss).val;</span><br><span class="line">        needfa = (infa - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        con = <span class="built_in">getCn</span>(needfa);</span><br><span class="line">        ans = ans * con % mod;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">        segid.<span class="built_in">update</span>(cur[i].ff, cur[i].ss, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; res[i] &lt;&lt; sendl[i == res.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>cf2700</tag>
        <tag>组合数学</tag>
        <tag>模拟实现</tag>
        <tag>并查集</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1979E E. Manhattan Triangle题解</title>
    <url>/2025/08/23/CF1979E-E-Manhattan-Triangle%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Manhattan-Triangle"><a href="#E-Manhattan-Triangle" class="headerlink" title="E. Manhattan Triangle"></a><a href="https://codeforces.com/contest/1979/problem/E">E. Manhattan Triangle</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们n个二维平面上的不同的点，我们要挑出三个点使得这三个点构成一个等边三角形边长为d（保证d是偶数），注意这里等边的边长意义是在曼哈顿距离下的。输出挑选哪三个点，无解输出0，0，0。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们容易根据曼哈顿距离的定义发现对于某个点而言，距离它为d的点围成了一个菱形，同时因为三角形的性质，在曼哈顿意义下的等边三角形总有一条边是在斜率为1的线段上的（这里可以通过画图加以发现理解）。所以我们可以考虑枚举一个节点，然后考虑另外两个节点在斜率为1的线段上，我们x从小到大枚举，通过维护[x - d, x] 与 [x, x + d]的斜率为1或-1上的点来进行快速的判断是否存在我们当前点菱形四线段上间距为d的点对，这里只用考虑同一个线段上的点对即可，因为上面曼哈顿意义下等边的性质。具体维护我采用了map套set实现，标记线段归属的斜率和初相我使用x + y, x - y来进行标识。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cur</span>(n + <span class="number">1</span>);</span><br><span class="line">    std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; ind;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line">        ind[&#123;cur[i].ff, cur[i].ss&#125;] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangx_d;    <span class="comment">//记录从x-d到x的斜率为1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiax_d;    <span class="comment">//记录从x-d到x的斜率为-1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangaddd; <span class="comment">//记录从x到x + d的斜率为1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiaaddd;   <span class="comment">//记录从x到x + d的斜率为-1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    </span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangx_dp;    <span class="comment">//记录从x-d到x的斜率为1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiax_dp;    <span class="comment">//记录从x-d到x的斜率为-1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangadddp; <span class="comment">//记录从x到x + d的斜率为1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiaadddp;   <span class="comment">//记录从x到x + d的斜率为-1的线段,存在距离为d的点的情况</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(cur.<span class="built_in">begin</span>() + <span class="number">1</span>, cur.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = cur[i].ff;</span><br><span class="line">        <span class="type">int</span> y = cur[i].ss;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右侧拓展</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt;= n &amp;&amp; cur[right].ff &lt;= x + d)&#123;</span><br><span class="line">            <span class="type">int</span> xn = cur[right].ff;</span><br><span class="line">            <span class="type">int</span> yn = cur[right].ss;</span><br><span class="line">            shangadddp[xn - yn].<span class="built_in">insert</span>(&#123;xn, yn&#125;);</span><br><span class="line">            xiaadddp[xn + yn].<span class="built_in">insert</span>(&#123;xn, yn&#125;);</span><br><span class="line">            <span class="keyword">if</span>(shangadddp[xn - yn].<span class="built_in">count</span>(&#123;xn -  d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                shangaddd[xn - yn].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(xiaadddp[xn + yn].<span class="built_in">count</span>(&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                xiaaddd[xn + yn].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            right += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左侧删除</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= i &amp;&amp; cur[left].ff &lt; x - d)&#123;</span><br><span class="line">            <span class="type">int</span> xn = cur[left].ff;</span><br><span class="line">            <span class="type">int</span> yn = cur[left].ss;</span><br><span class="line">            shangx_dp[xn - yn].<span class="built_in">erase</span>(&#123;xn, yn&#125;);</span><br><span class="line">            xiax_dp[xn + yn].<span class="built_in">erase</span>(&#123;xn, yn&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shangx_dp[xn - yn].<span class="built_in">count</span>(&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);  </span><br><span class="line">                shangx_d[xn - yn].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(xiax_dp[xn + yn].<span class="built_in">count</span>(&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);  </span><br><span class="line">                xiax_d[xn + yn].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左侧拓展</span></span><br><span class="line">        shangx_dp[x - y].<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">        xiax_dp[x + y].<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(shangx_dp[x - y].<span class="built_in">count</span>(&#123;x -  d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            shangx_d[x - y].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xiax_dp[x + y].<span class="built_in">count</span>(&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            xiax_d[x + y].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取是否存在匹配</span></span><br><span class="line">        <span class="type">int</span> needx = x + d;</span><br><span class="line">        <span class="type">int</span> needy = y;</span><br><span class="line">        <span class="keyword">if</span>(!shangaddd[needx - needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *shangaddd[needx - needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!xiaaddd[needx + needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *xiaaddd[needx + needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        needx = x - d;</span><br><span class="line">        needy = y;</span><br><span class="line">        <span class="keyword">if</span>(!shangx_d[needx - needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *shangx_d[needx - needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!xiax_d[needx + needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *xiax_d[needx + needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右侧删除</span></span><br><span class="line">        shangadddp[x - y].<span class="built_in">erase</span>(&#123;x, y&#125;);</span><br><span class="line">        xiaadddp[x + y].<span class="built_in">erase</span>(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(shangadddp[x - y].<span class="built_in">count</span>(&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            shangaddd[x - y].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xiaadddp[x + y].<span class="built_in">count</span>(&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            xiaaddd[x + y].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">0</span> &lt;&lt; space &lt;&lt; <span class="number">0</span> &lt;&lt; space &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2400</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>模拟实现</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2063F1 F1. Counting Is Not Fun (Easy Version)题解</title>
    <url>/2025/08/21/CF2063F1-F1-Counting-Is-Not-Fun-Easy-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F1-Counting-Is-Not-Fun-Easy-Version"><a href="#F1-Counting-Is-Not-Fun-Easy-Version" class="headerlink" title="F1. Counting Is Not Fun (Easy Version)"></a><a href="https://codeforces.com/contest/2063/problem/F1">F1. Counting Is Not Fun (Easy Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个数字n，代表一个有着n个好对的括号序列，一个好对（i, j) (i &lt; j) 满足s[i] &#x3D;&#x3D; ‘(‘, s[j] &#x3D;&#x3D; ‘)’同时去掉i，j两个字符，区间内剩余的子串是一个合法的平衡括号字符串，可以证明对于一个长度位2 * n的括号序列一定有n个好对。题目依次给出n个好对，我们需要计算出前i个好对确定的情况下有多少种符号要求的合法括号字符串（i从0到n）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们根据题目的定义我们发现对于一个好对[l, r]其中l - 1， r - 1可以填任何合法的括号序列，所以我们需要预处理出长度x时的合法括号序列数，这可以通过dp[len] [diff]来n ^ 2的dp处理出来，状态表示长度为len时平衡度为diff的括号序列数量。然后考虑如何根据确定了的好对来计算可能的括号序列种类。我们发现一个好对就可以把其包含区间的种类给算出来，并且按照定义好对不会相交，只有可能包含，包含时我们可以用来填的空要是还没有确定的，也就是去掉包含的好对长度，于是对于前i个，我们可以通过维护左端点第一关键，右端点第二关键，有序的好对前缀，来O（n）的计算出每个好对还可以填写的空，结合dp[len] [0]相乘计数即可，最后乘上剩余所有没填的空的贡献即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> N = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span> * N + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (<span class="number">1LL</span> * dp[i][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; N)</span><br><span class="line">                dp[i][j] = (<span class="number">1LL</span> * dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + dp[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cur</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;ll&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(dp[<span class="number">2</span> * n][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">occur</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    cur[<span class="number">0</span>].ff = <span class="number">0</span>;</span><br><span class="line">    cur[<span class="number">0</span>].ss = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ind = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[qu[j]].ff &lt;= cur[i].ff || (cur[qu[j]].ff == cur[i].ff &amp;&amp; cur[qu[j]].ss &lt;= cur[i].ss))&#123;</span><br><span class="line">                ind = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; i &lt;&lt; space &lt;&lt; ind &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= ind; j++)</span><br><span class="line">            now.<span class="built_in">push_back</span>(qu[j]);</span><br><span class="line">        now.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = ind + <span class="number">1</span>; j &lt; qu.<span class="built_in">size</span>(); j++)</span><br><span class="line">            now.<span class="built_in">push_back</span>(qu[j]);</span><br><span class="line">        qu = now;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// for(int j = 0; j &lt; qu.size(); j++)</span></span><br><span class="line">        <span class="comment">//     std::cerr &lt;&lt; qu[j] &lt;&lt; sendl[j == qu.size() - 1];</span></span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            occur[j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ind : qu)&#123;</span><br><span class="line">            <span class="type">int</span> l = cur[ind].ff;</span><br><span class="line">            <span class="type">int</span> r = cur[ind].ss;</span><br><span class="line">            <span class="keyword">while</span>(cur[stk.<span class="built_in">top</span>()].ss &lt; r)</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            occur[stk.<span class="built_in">top</span>()] += r - l + <span class="number">1</span>;</span><br><span class="line">            stk.<span class="built_in">push</span>(ind);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            ll use = <span class="number">2</span> + occur[j];</span><br><span class="line">            ll last = (cur[j].ss - cur[j].ff + <span class="number">1</span>) - use;</span><br><span class="line">            ans = (ans * dp[last][<span class="number">0</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ll last = <span class="number">2</span> * n - occur[<span class="number">0</span>];</span><br><span class="line">        ans = (ans * dp[last][<span class="number">0</span>]) % mod;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; res[i] &lt;&lt; sendl[i == res.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2400</tag>
        <tag>组合数学</tag>
        <tag>模拟实现</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2064E E. Mycraft Sand Sort题解</title>
    <url>/2025/08/04/CF2064E%20E.%20Mycraft%20Sand%20Sort%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Mycraft-Sand-Sort"><a href="#E-Mycraft-Sand-Sort" class="headerlink" title="E. Mycraft Sand Sort"></a><a href="https://codeforces.com/problemset/problem/2064/E">E. Mycraft Sand Sort</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的排列，代表n行沙子，其元素大小就是第i行沙子的长度。题目还给我们一个长度为n的数组，其数组元素的值代表第i行沙子的颜色。最终沙子会因重力而落下，我们要计算初始有多少种排列和颜色的组合可以使得最终沙子落下来的效果与给定的一样，注意对998244353取模。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们通过观察发现本题的一个重要性质，数组的颜色数组是不会发生改变的，因为每一行的沙子的长度都大于等于1。所以第一格的元素的颜色就把整个数组的颜色给定了下来。并且长度为i的沙子是什么颜色也不会改变，所以方案数会增多就来源于同色的沙子之间的交换。我们发现对于颜色相同的第x行和第y行沙子可以交换的条件是沙子x和y之间不存在比其长度最小值大的异色沙子行，我们可以使用并查集和链表，从长度最小的沙子行开始考虑交换维护这个过程计算答案。</p>
<p>​	注意这里有一个误区，用并查集从小到大合并之后阶乘计算贡献是错误的，其并不可以保证我们的交换条件合法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">len</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; len[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; col[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> dsu = <span class="built_in">DSU</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">R</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[i] == col[i - <span class="number">1</span>])</span><br><span class="line">            dsu.<span class="built_in">merge</span>(i, i - <span class="number">1</span>);</span><br><span class="line">        L[i] = i - <span class="number">1</span>;</span><br><span class="line">        R[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">op</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        op[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(op.<span class="built_in">begin</span>(), op.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> len[a] &lt; len[b];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos : op)&#123;</span><br><span class="line"></span><br><span class="line">        ans = (ans * dsu.<span class="built_in">size</span>(pos)) % mod;</span><br><span class="line">        dsu.siz[dsu.<span class="built_in">find</span>(pos)] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dsu.<span class="built_in">size</span>(pos) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(col[L[pos]] == col[R[pos]] &amp;&amp; col[R[pos]] != <span class="number">0</span>)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(L[pos], R[pos]);</span><br><span class="line"></span><br><span class="line">        R[L[pos]] = R[pos];</span><br><span class="line">        L[R[pos]] = L[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2400</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>arc203_d D - Insert XOR题解</title>
    <url>/2025/08/22/arc203-d-D-Insert-XOR%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D-Insert-XOR"><a href="#D-Insert-XOR" class="headerlink" title="D - Insert XOR"></a><a href="https://atcoder.jp/contests/arc203/tasks/arc203_d"><strong>D - Insert XOR</strong></a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的二进制字符串，我们要处理q次操作，每次操作给我们一个pos，我们会翻转s[pos]，我们每次操作后都要输出当前字符串的最小代价，操作是持久化的。一个二进制字符串的代价为需要的最小的初始字符串长度，使得我们可以通过对这个初始字符串进行若干次操作来得到当前字符串，我们可以进行的操作是选择两个相邻的字符元素，在其中间插入两个数异或的结果。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	我们考虑代价时从当前数组删减到最小的字符串长度来考虑会更容易，首先我们发现我们需要特判掉全部为1的情况，此时需要的初始字符串一定长度为n，然后剩余的情况我们可以进行的删减实际上就三种情况</p>
<pre><code>	1. 11 -&gt; 1 (要求当前字符串中存在0) 2. 000 -&gt; 00 (无要求) 3. 101 -&gt; 1 (要求当前字符串除这个对还存在0)
</code></pre>
<p>​    我们考虑吧维护每个元素对答案减小的贡献，则此时cur[i] &#x3D;&#x3D; 1 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 1, 此时位置i贡献为1，cur[i] &#x3D;&#x3D; 0 &amp;&amp; cur[i + 1] &#x3D;&#x3D; 0 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 0,此时位置i贡献为1，cur[i] &#x3D;&#x3D; 0 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 1 &amp;&amp; cur[i + 1] &#x3D;&#x3D; 1,此时位置i的贡献为2，我们最后的答案就是n - 贡献和，注意答案为1时实际上要特判成2，因为我们不可能缩到1，再特判掉全1的情况即可，上面三种贡献实际上和三种删减情况一一对应。本题还有实现起来较为麻烦的线段树解法，我们直接用线段树维护区间的删减情况进行合并即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(n + <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">1</span>)</span><br><span class="line">            cnt1 += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">1</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">0</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[i + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">0</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[i + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> getans = [&amp;]()&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == n)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="number">2</span>, n - sum);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> del = [&amp;](<span class="type">int</span> pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span>)</span><br><span class="line">            cnt1 -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum -= <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span>)</span><br><span class="line">            cnt1 += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pos;</span><br><span class="line">        std::cin &gt;&gt; pos;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">del</span>(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">del</span>(pos);</span><br><span class="line">        <span class="built_in">del</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cur[pos] ^= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(pos);</span><br><span class="line">        <span class="built_in">add</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">getans</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>atcoder2400</tag>
      </tags>
  </entry>
  <entry>
    <title>李超线段树模板(class)</title>
    <url>/2025/08/07/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF-class/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ShadowDrunk</span></span><br><span class="line"><span class="comment">//李超线段树实际上是维护在二维坐标系上插入线段，同时查询x == d时y最大的线段是哪个以及对应的值的变式线段树</span></span><br><span class="line"><span class="comment">//我们发现一个线段可以看作作用域在[x0, x1]上的一次函数，我们维护函数即可</span></span><br><span class="line"><span class="comment">//我们给每个节点打上标记用于懒操作，每个标记都是一个完全覆盖当前区间的线段</span></span><br><span class="line"><span class="comment">//当我们插入一个线段时我们把它拆分到其包含的所有区间去考虑它的影响</span></span><br><span class="line"><span class="comment">//考虑当前插入线段对其覆盖区间的影响，将当前线段和之前标记线段在mid处更优秀的留做懒标记</span></span><br><span class="line"><span class="comment">//mid处更劣的线段看在两边是否和更优线段存在交点</span></span><br><span class="line"><span class="comment">//显然最多左边或右边，有且只有一边可能存在交点，我们把更劣的线段递归下传继续考虑</span></span><br><span class="line"><span class="comment">//在处理查询时我们类似于标记永久化的思想遍历包含的所有节点（包含路径中的节点），取所有节点标记的线段中最优的</span></span><br><span class="line"><span class="comment">//这是因为我们标记的线段一定是最优的或是最优的是其父亲节点中的标记，但还没有下传，我们遍历了所有路径节点，最优线段一定在其中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiSegTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//李超线段树</span></span><br><span class="line"><span class="comment">//该模板维护的是线段对应k点最大的y归属于哪个序号最小的线段</span></span><br><span class="line"><span class="comment">//若需要修改成y最小需要修改用pmin以及改change内部的比较逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改O(lgn * lgn), 查询O(lgn)</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//x轴值域[1, n]</span></span><br><span class="line">    <span class="type">int</span> m;  <span class="comment">//插入的线段的最大数量</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回x与y的大小关系，1则x大，0相等，-1则y大</span></span><br><span class="line">        <span class="keyword">if</span>(x - y &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y - x &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">        <span class="comment">//记录线段斜率和截距</span></span><br><span class="line">        <span class="type">double</span> k, b;</span><br><span class="line">        <span class="built_in">line</span>(<span class="type">double</span> _k, <span class="type">double</span> _b)&#123;</span><br><span class="line">            k = _k; b = _b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">line</span>()&#123;</span><br><span class="line">            k = <span class="number">0</span>; b = -inf;</span><br><span class="line">            <span class="comment">//b == inf; //维护y最小时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;line&gt; p;    <span class="comment">//记录插入的线段</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//内部线段的数量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tag; <span class="comment">//记录区间标记属于哪个线段, 每个标记都是一个线段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> id, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算id对应线段在x == d时的值</span></span><br><span class="line">        <span class="keyword">return</span>  p[id].b + p[id].k * d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="comment">//插入线段, (x0, y0), (x1, y1) 为线段两个端点</span></span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x0 == x1)&#123;</span><br><span class="line">            p[cnt].k = <span class="number">0</span>;</span><br><span class="line">            p[cnt].b = std::<span class="built_in">max</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p[cnt].k = <span class="number">1.0</span> * (y1 - y0) / (x1 - x0);</span><br><span class="line">            p[cnt].b = y0 - p[cnt].k * x0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> root, T pl, T pr, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改被完全覆盖的区间的标记</span></span><br><span class="line">        <span class="type">int</span> &amp;v = tag[root];</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bmid = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, mid), <span class="built_in">calc</span>(v, mid));</span><br><span class="line">        <span class="keyword">if</span>(bmid == <span class="number">1</span> || (!bmid &amp;&amp; u &lt; v))</span><br><span class="line">            std::<span class="built_in">swap</span>(u, v);    <span class="comment">//确保u线段在mid处小于等于v线段</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bl = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pl), <span class="built_in">calc</span>(v, pl));</span><br><span class="line">        <span class="type">int</span> br = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pr), <span class="built_in">calc</span>(v, pr));</span><br><span class="line">        <span class="comment">//判断那边的区间存在交点</span></span><br><span class="line">        <span class="keyword">if</span>(bl == <span class="number">1</span> || (!bl &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, u);</span><br><span class="line">        <span class="keyword">if</span>(br == <span class="number">1</span> || (!br &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, u);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面两个if最多只会触发一个这保证了修改的复杂度</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //y最小代码</span></span><br><span class="line"><span class="comment">            if(bmid == -1 || (!bmid &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                std::swap(u, v);    //确保u线段在mid处大于等于v线段</span></span><br><span class="line"><span class="comment">            if(bl == -1 || (!bl &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change(root &lt;&lt; 1, pl, mid, u);</span></span><br><span class="line"><span class="comment">            if(br == -1 || (!br &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change((root &lt;&lt; 1) | 1, mid + 1, pr, u);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> root, T pl, T pr, T l, T r, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= pl &amp;&amp; pr &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">change</span>(root, pl, pr, u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, l, r, u);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, l, r, u); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmax</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmin</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> root, T l, T r, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询x == d时的答案</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt; d || l &gt; d)</span><br><span class="line">            <span class="keyword">return</span> &#123;-inf, <span class="number">0</span>&#125;;  <span class="comment">//维护y最小 return &#123;inf, 0&#125;;</span></span><br><span class="line">        T mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="built_in">calc</span>(tag[root], d);</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> &#123;res, tag[root]&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, tag[root]&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(root &lt;&lt; <span class="number">1</span>, l, mid, d),</span><br><span class="line">        <span class="built_in">query</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, d)));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //维护y最小时使用</span></span><br><span class="line"><span class="comment">            return pmin(&#123;res, s[root]&#125;, pmin(query(root &lt;&lt; 1, l, mid, d),</span></span><br><span class="line"><span class="comment">            query((root &lt;&lt; 1) | 1, mid + 1, r, d)));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addline</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x0 &gt; x1)&#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(x0, x1);</span><br><span class="line">            std::<span class="built_in">swap</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(x0, y0, x1, y1);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x0, x1, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>(<span class="type">int</span> _n, <span class="type">int</span> _m)&#123;</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>()&#123;</span><br><span class="line">        n = <span class="number">5e5</span>, m = <span class="number">5e5</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
