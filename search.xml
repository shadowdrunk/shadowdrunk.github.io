<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024昆明区域赛 B. Brackets 题解</title>
    <url>/2025/08/31/2024%E6%98%86%E6%98%8E%E5%8C%BA%E5%9F%9F%E8%B5%9B-B-Brackets-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="B-Brackets"><a href="#B-Brackets" class="headerlink" title="B. Brackets"></a><a href="https://codeforces.com/gym/105588/problem/B">B. Brackets</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的括号序列，该括号序列包含4种括号(), [], {}, &lt;&gt;。一个合法的括号序列的定义是LxR，L和R是同种类的括号的左右括号，x是一个合法的括号序列，x &#x3D; y1y2，y1y2为两个合法的括号序列。题目还给我们m个子区间，我们需要计算这些子区间的括号序列进行两两匹配最多可以形成多少对合法的括号序列。(gym原题链接,复制粘贴前往 <a href="https://codeforces.com/gym/105588/problem/B">https://codeforces.com/gym/105588/problem/B</a>)</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们通过观察题目的合法括号序列的性质可以发现，对于一个合法的括号序列，如果我们将其拆分成两半，那么要么两半初始都是合法的，要么左半去掉已经匹配的可以缩成一系列的左括号，右半也是同理。考虑吧如何处理出每个区间是什么样的情况，我们继续观察发现对于左半的情况我们可以直接使用括号栈来维护前缀种待匹配的左括号，在每个右端点时考虑区间是否可以作为左半边，当出现无法匹配的位置时我们需要清空栈并且标记1到i（i为当前考虑的位置），这些位置均不可以作为区间的左端点。同时我们呢注意到对于产生匹配括号的区间[l, r]，[l + 1, r]都不可以作为左端点，因为这样一定会剩下一个右括号多出来。对于每个区间还有什么样的括号等待着匹配我们可以直接字符串哈希即可快速解决。</p>
<p>​	具体实现方面，我使用线段树来标记哪些点不可以作为左端点，然后对于括号栈同时维护下标，通过二分查找区间的待匹配括号哈希，同时动态维护括号栈的前缀哈希值。最后对于作为右半的括号，我们可以把括号序列和区间翻转，当作左半的情况再左一次。最后计算答案，注意已经匹配的区间不要数重复。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T val;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.val = a.val + b.val;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = a[pl];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        tree[p].val += (pr - pl + <span class="number">1</span>) * d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N = <span class="number">5e5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ull PP = <span class="number">131</span>;</span><br><span class="line">std::vector&lt;ull&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P.<span class="built_in">assign</span>(N + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        P[i] = P[i - <span class="number">1</span>] * PP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot;@&quot;</span> + s;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">ask</span>(m + <span class="number">1</span>);</span><br><span class="line">    std::vector&lt;std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">pos</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; ask[i].ff &gt;&gt; ask[i].ss;</span><br><span class="line">        pos[ask[i].ss].<span class="built_in">push_back</span>(&#123;ask[i].ff, i&#125;);</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; s.substr(ask[i].ff, ask[i].ss - ask[i].ff + 1) &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::deque&lt;ull&gt; stkhash;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">char</span> c)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                || (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;&#123;&#x27;</span>) || (c == <span class="string">&#x27;&gt;&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;&lt;&#x27;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::map&lt;ull, <span class="type">int</span>&gt; mp[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> work = [&amp;](<span class="type">int</span> mode)&#123;</span><br><span class="line">        ind.<span class="built_in">clear</span>();</span><br><span class="line">        stkhash.<span class="built_in">clear</span>();</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                ind.<span class="built_in">push_back</span>(i);</span><br><span class="line">                ull val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(stkhash.<span class="built_in">size</span>())</span><br><span class="line">                    val = stkhash.<span class="built_in">back</span>();</span><br><span class="line">                val = val * PP + s[i];</span><br><span class="line">                stkhash.<span class="built_in">push_back</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(s[i]))&#123;</span><br><span class="line">                    <span class="type">int</span> right = i;</span><br><span class="line">                    <span class="type">int</span> left = ind.<span class="built_in">back</span>();</span><br><span class="line">                    <span class="comment">//除了匹配括号的左括号下标，其余都不可以作为左端点</span></span><br><span class="line">                    seg.<span class="built_in">update</span>(left + <span class="number">1</span>, right, <span class="number">1</span>);</span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ind.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stkhash.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    seg.<span class="built_in">update</span>(<span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">                    ind.<span class="built_in">clear</span>();</span><br><span class="line">                    stkhash.<span class="built_in">clear</span>();</span><br><span class="line">                    stk.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[l, id] : pos[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(seg.<span class="built_in">query</span>(l, l).val == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> left = l;</span><br><span class="line">                    <span class="type">int</span> right = i;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> hasleft = std::<span class="built_in">lower_bound</span>(ind.<span class="built_in">begin</span>(), ind.<span class="built_in">end</span>(), left) - ind.<span class="built_in">begin</span>();</span><br><span class="line">                    <span class="type">int</span> hasright = std::<span class="built_in">upper_bound</span>(ind.<span class="built_in">begin</span>(), ind.<span class="built_in">end</span>(), right) - ind.<span class="built_in">begin</span>();</span><br><span class="line">                    hasright -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(hasright &gt;= hasleft)&#123;</span><br><span class="line">                        ull pre = (hasleft == <span class="number">0</span> ? <span class="number">0</span> : stkhash[hasleft - <span class="number">1</span>]);</span><br><span class="line">                        <span class="type">int</span> len = hasright - hasleft + <span class="number">1</span>;</span><br><span class="line">                        ull hash = stkhash[hasright] - pre * P[len];</span><br><span class="line">                        mp[mode][hash] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(mode == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//此时一定是区间不包含任何待匹配段，mode == 0时计数</span></span><br><span class="line">                        zero += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">work</span>(<span class="number">0</span>);    <span class="comment">//mode 0 for left</span></span><br><span class="line">    pos = std::vector&lt;std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> r = n + <span class="number">1</span> - ask[i].ff;</span><br><span class="line">        <span class="type">int</span> l = n + <span class="number">1</span> - ask[i].ss;</span><br><span class="line">        pos[r].<span class="built_in">push_back</span>(&#123;l, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> last = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> need = n + <span class="number">1</span> - i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">        s[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">work</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>[hash, num] : mp[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="type">int</span> oth = mp[<span class="number">1</span>][hash];</span><br><span class="line">        ans += std::<span class="built_in">min</span>(num, oth);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += zero / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>区域赛</tag>
        <tag>2024昆明区域赛</tag>
        <tag>金牌题</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模拟实现</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1858E2 E2. Rollbacks (Hard Version)题解</title>
    <url>/2025/09/01/CF1858E2-E2-Rollbacks-Hard-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E2-Rollbacks-Hard-Version"><a href="#E2-Rollbacks-Hard-Version" class="headerlink" title="E2. Rollbacks (Hard Version)"></a><a href="https://codeforces.com/contest/1858/problem/E2">E2. Rollbacks (Hard Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	初始有一个空的数组，我们需要对它进行q次操作，我们可以执行4种操作，操作+，添加一个元素x到数组后面。操作-，移除数组末尾的k个数字，操作！，撤回上一个操作，只会撤回+，-。操作？，输出数组种不同种类的数的个数。保证操作合法，hard版本要求强制在线。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先本题我们看见其回退操作自然考虑使用可持久化的数据结构进行维护，考虑可持久化线段树，发现我们可以维护一个权值线段树表示每个值得元素是否有贡献，添加操作实际上就是新版本新建一个单点处理，减去操作实际上就是创建一个当前版本的k级祖先的镜像版本，回退操作实际上就是直接删去一个版本即可。考虑如何快速回调k级版本的祖先，我们可以维护倍增，记录每个版本的父亲版本倍增状态。但这样写完之后我们发现会MLE，经过计算我们发现我们最多只有1.4e7的空间给可持久化线段树，这是不够的，考虑优化，我们只用标记某个值是否做了贡献，所以我们可以进行状态压缩，把所有长度为32的区间压缩到一个int里，这样我们线段树的值域范围可以&#x2F;32，这样我们需要1.6e7的空间。我们发现还是不够，考虑从倍增上搞点空间出来，以时间换空间倍增数组只用维护到2  ^ 17即可，这样我们就可以多出2e6的空间，就可以通过本题。</p>
<p>​	本题还有O（q）的解法，我们发现我们实际上可以维护当前数组的长度，每个数我们记录其最早出现的位置来做贡献，这样我们查询答案实际上相当于查询长度为len的前缀，我们可以同时维护长度为len的答案ans[len]即可，加的操作我们修改之前这个位置的数，删去贡献处理新加的数覆盖即可。减操作直接len -&#x3D; k即可。这样我们就解决了没有回退操作的解法，考虑如何处理回退操作，我们可以用栈维护每个操作带来的影响，最后直接弹出栈里的操作恢复状态即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(qlgq) 可持久化线段树</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//记录可以使用的新节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls;</span><br><span class="line">    <span class="type">int</span> rs;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> root[<span class="number">1000001</span>];</span><br><span class="line">node tree[<span class="number">16500001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">1000001</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> depth[<span class="number">1000001</span>];</span><br><span class="line"><span class="comment">//要开的空间数为n * lg(4 * n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建一颗只有lgn个新节点的新线段树</span></span><br><span class="line">    <span class="type">int</span> rt = ++cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cerr &lt;&lt; pl &lt;&lt; space &lt;&lt; pr &lt;&lt; space &lt;&lt; cnt &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">        <span class="type">int</span> now = x % <span class="number">32</span>;</span><br><span class="line">        tree[rt].val = tree[pre].val;</span><br><span class="line">        now = (now - <span class="number">1</span> + <span class="number">32</span>) % <span class="number">32</span>;</span><br><span class="line">        tree[rt].val |= (<span class="number">1</span> &lt;&lt; now);</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将该节点的左右儿子初始化为和上一颗线段树一样</span></span><br><span class="line">    tree[rt].ls = tree[pre].ls;</span><br><span class="line">    tree[rt].rs = tree[pre].rs;</span><br><span class="line">    <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pl &lt; pr)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x + <span class="number">32</span> - <span class="number">1</span>) / <span class="number">32</span> &lt;= mid)</span><br><span class="line">            tree[rt].ls = <span class="built_in">update</span>(tree[pre].ls, pl, mid, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[rt].rs = <span class="built_in">update</span>(tree[pre].rs, mid + <span class="number">1</span>, pr, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree[rt].val = (pl == mid ? __builtin_popcount(tree[tree[rt].ls].val) : tree[tree[rt].ls].val)</span><br><span class="line">         + (pr == mid + <span class="number">1</span> ? __builtin_popcount(tree[tree[rt].rs].val) : tree[tree[rt].rs].val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">        <span class="type">int</span> now = x % <span class="number">32</span>;</span><br><span class="line">        now = (now - <span class="number">1</span> + <span class="number">32</span>) % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> ((tree[p].val &gt;&gt; now) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((x + <span class="number">32</span> - <span class="number">1</span>) / <span class="number">32</span> &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[p].ls, pl, mid, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[p].rs, mid + <span class="number">1</span>, pr, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1e6</span>;</span><br><span class="line">    <span class="type">int</span> maxn = (<span class="number">1e6</span> + <span class="number">32</span> - <span class="number">1</span>) / <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> getk = [&amp;](<span class="type">int</span> x, <span class="type">int</span> k)&#123;</span><br><span class="line">        k = std::<span class="built_in">min</span>(depth[x], k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">14</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= (<span class="number">1</span> &lt;&lt; i))&#123;</span><br><span class="line">                k -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                x = fa[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> father;</span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line"></span><br><span class="line">        std::cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            root[top] = <span class="built_in">update</span>(root[top - <span class="number">1</span>], <span class="number">1</span>, maxn, val);</span><br><span class="line">            father = top - <span class="number">1</span>;</span><br><span class="line">            node = top;</span><br><span class="line">            fa[node][<span class="number">0</span>] = father;</span><br><span class="line">            depth[node] = depth[father] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= <span class="number">14</span>; j++)&#123;</span><br><span class="line">                fa[node][j] = fa[fa[node][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            from = <span class="built_in">getk</span>(top - <span class="number">1</span>, val);</span><br><span class="line">            root[top] = root[from];</span><br><span class="line">            depth[top] = depth[from];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">                fa[top][j] = fa[from][j];</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">            top -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; tree[root[top - <span class="number">1</span>]].val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(q)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tm</span><span class="params">(N + <span class="number">2</span>, N + <span class="number">1</span>)</span></span>;  <span class="comment">//记录每个值得最早出现得位置</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">con</span><span class="params">(N + <span class="number">2</span>, <span class="number">0</span>)</span></span>;     <span class="comment">//记录位置i的数是否产生了贡献</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ref</span><span class="params">(N + <span class="number">2</span>, <span class="number">0</span>)</span></span>;     <span class="comment">//记录位置i的之前的数是什么</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(N + <span class="number">2</span>, <span class="number">0</span>)</span></span>;     <span class="comment">//记录此时长度为i的序列的答案</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save0</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//for tm[val]</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save1</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//for tm[ref[len]]</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save2</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//fot ref</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save3</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//for ans</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        std::cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            stk[top] = val;</span><br><span class="line">            len = len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            save1[top] = tm[ref[len]];</span><br><span class="line">            save0[top] = tm[val];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tm[ref[len]] == len)&#123;</span><br><span class="line">                con[len] = <span class="literal">false</span>;</span><br><span class="line">                tm[ref[len]] = <span class="number">0</span>;   <span class="comment">//将之前这个位置的最小出现位重置，这里不用考虑下一个相同元素，要么添加覆盖，要么回退</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tm[val] == <span class="number">0</span> || tm[val] &gt;= len)&#123;</span><br><span class="line">                <span class="comment">//取消远处标记的标记的贡献</span></span><br><span class="line">                con[tm[val]] = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//重置最小的元素出现位置</span></span><br><span class="line">                tm[val] = len;</span><br><span class="line">                con[len] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            save2[top] = ref[len];</span><br><span class="line">            ref[len] = val;</span><br><span class="line"></span><br><span class="line">            save3[top] = ans[len];</span><br><span class="line">            ans[len] = ans[len - <span class="number">1</span>] + con[len];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            len = len - val;</span><br><span class="line">            stk[top] = -val;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk[top] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans[len] = save3[top];</span><br><span class="line">                ref[len] = save2[top];</span><br><span class="line">                <span class="keyword">if</span>(save0[top] == <span class="number">0</span> || save0[top] &gt;= len)&#123;</span><br><span class="line">                    con[len] = <span class="literal">false</span>;</span><br><span class="line">                    tm[stk[top]] = save0[top];</span><br><span class="line">                    con[tm[stk[top]]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(save1[top] == len)&#123;</span><br><span class="line">                    con[len] = <span class="literal">true</span>;</span><br><span class="line">                    tm[save2[top]] = len;</span><br><span class="line">                &#125;</span><br><span class="line">                len -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len -= stk[top];</span><br><span class="line">            &#125;</span><br><span class="line">            top -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; ans[len] &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; i &lt;&lt; space &lt;&lt; len &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>cf2600</tag>
        <tag>可持久化线段树(主席树)</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1934 D2. XOR Break — Game Version题解</title>
    <url>/2025/08/22/CF1934%20D2-XOR-Break-%E2%80%94-Game-Version%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D2-XOR-Break-—-Game-Version"><a href="#D2-XOR-Break-—-Game-Version" class="headerlink" title="D2. XOR Break — Game Version"></a><a href="https://codeforces.com/problemset/problem/1934/D2">D2. XOR Break — Game Version</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个初始数字n，我们要和对手进行博弈，我们可以选择先后手，我们与对手进行的游戏是这样的，当前数字初始为p，当前回合的选手需要构造两个数字p1，p2，满足（0 &lt; p1 &lt; p, 0 &lt; p2 &lt; p, p1 ^ p2 &#x3D;&#x3D; p)，若无法构造出p1，p2则当前回合玩家输，然后另一个人挑选其中任意一个数作为当前数字p，并开始它的回合。我们最多可以进行63次回合，需要保证必胜。初始数字n &lt; 1e18。交互题，系统给出对面的操作。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们可以发现一个关键的边界条件，当初始数字中为1的位为1时我们无法对其进行拆解，此时是必败态。我们考虑如何让对手到达这个状态或是这个状态由和转移过来。一个简单的必胜态是有两位数的情况，此时我们拆成两个1位为1的位的数则必胜。继续推广我们发现通过构造所有的为1的位为偶数时都是必胜态，奇数都是必败态，具体证明如下，对于一个偶数个位为1的数我们一定可以把其拆成两个为1的位为奇数的数，而对于为1的位为偶数的数我们无论怎么拆都是一奇数位为1，一个偶数位为1，所以我们只要继续挑选那个偶数位1的数进行拆分就可继续必胜。具体的拆分为了减少对面新增的1的位，我们直接把最高位1拆走，剩余的构成另外一个数即可，在题目要求下易证操作回合小于等于63。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcnt</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">63</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">getcnt</span>(n);</span><br><span class="line">    ll p1 = n;</span><br><span class="line">    ll p2 = n;</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> op = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="number">0</span> &amp;&amp; p2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        op += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getcnt</span>(p1) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(p1, p2);</span><br><span class="line">        ll out1 = (<span class="number">1LL</span> &lt;&lt; std::__lg(p1));</span><br><span class="line">        ll out2 = (p1 ^ out1);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; out1 &lt;&lt; space &lt;&lt; out2 &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>博弈论</tag>
        <tag>cf2400</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1945G G. Cook and Porridge题解</title>
    <url>/2025/09/06/CF1945G-G-Cook-and-Porridge%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="G-Cook-and-Porridge"><a href="#G-Cook-and-Porridge" class="headerlink" title="G. Cook and Porridge"></a><a href="https://codeforces.com/contest/1945/problem/G">G. Cook and Porridge</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们n个排着队的学生，每个学生都有一个优先级和吃饭时间，初始时按照1到n排序，每一秒在最前面的学生可以得到吃的，然后他会花费s[i]的吃饭时间吃饭，记录当前时间为x，则他会在x + s[i]的时刻结束时回来排队，此时对尾所有优先即严格低于他的学生都会被他插队，直到遇到优先级大于等于他的。我们需要计算1到d秒内所有学生都吃过一回饭的最小时刻，或者报告不可能。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	注意到d的数据范围很小，同时每个时刻只有一个学生会吃饭，所以归队的学生也最多d个，考虑模拟这个过程。我们发现因为初始状态的优先级不是单调的我们很难处理，但是我们可以注意到每次插入后当前元素所在的那个小块一定是优先级别大到小的递减的。所以我们考虑维护初始状态的后缀最大值，我们每次学生归队时通过二分找出他会被拦截在哪个块的后面，然后在这个块的后面插入，此时每个块中的元素都是优先级单调的，我们可以直接使用set维护即可，每一块中优先级大的靠钱，相同则比较插入时间，插入时间小的考前。我们在开一个set维护哪几个块中有元素即可取出队首的元素。记录每个学生是否吃过饭，全吃过记录答案退出即可。</p>
<p>​	另外一种比较简单的实现方式是直接使用平衡树，注意到如果初始队列的优先级别是单调的我们直接使用一个优先队列即可维护。我们发现插入的规则是固定的，但初始的元素可能不满足这个规则，我们可以直接用平衡树手动初始化节点，最后按照规则插入即可。具体的可以维护每个子树内节点的优先级最大值，队首就是最左侧存活的节点。我的代码使用的替罪羊树进行实现。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set维护</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> ci;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">k</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; k[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">suf</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        suf[i] = std::<span class="built_in">max</span>(suf[i + <span class="number">1</span>], k[i]);</span><br><span class="line">        res.<span class="built_in">push_back</span>(suf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k[a.ff] != k[b.ff])</span><br><span class="line">            <span class="keyword">return</span> k[a.ff] &gt; k[b.ff];</span><br><span class="line">        <span class="keyword">return</span> a.ss &lt; b.ss;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt;&gt; <span class="built_in">pos</span>(n + <span class="number">1</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt;(cmp));</span><br><span class="line">    <span class="comment">//[id, cha]</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; se;   <span class="comment">//pos who has num</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        pos[i].<span class="built_in">insert</span>(&#123;i, i&#125;);</span><br><span class="line">        se.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cha = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">time</span>(d + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; i++)&#123;</span><br><span class="line">        <span class="type">int</span> who = *se.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> p = *pos[who].<span class="built_in">begin</span>();</span><br><span class="line">        pos[who].<span class="built_in">erase</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(pos[who].<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            se.<span class="built_in">erase</span>(who);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!vis[p.ff])&#123;</span><br><span class="line">            vis[p.ff] = <span class="literal">true</span>;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + s[p.ff] &lt;= d)&#123;</span><br><span class="line">            time[i + s[p.ff]].<span class="built_in">push_back</span>(p.ff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(time[i].<span class="built_in">begin</span>(), time[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[a] &lt; s[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : time[i])&#123;</span><br><span class="line">            <span class="type">int</span> now = k[x];</span><br><span class="line">            <span class="type">int</span> ind = std::<span class="built_in">lower_bound</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), now) - res.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> qu = n - ind;</span><br><span class="line">            pos[qu].<span class="built_in">insert</span>(&#123;x, cha&#125;);</span><br><span class="line">            <span class="keyword">if</span>(pos[qu].<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">                se.<span class="built_in">insert</span>(qu);</span><br><span class="line">            &#125;</span><br><span class="line">            cha += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt == n)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; (ans == <span class="number">0</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平衡树维护</span></span><br><span class="line"><span class="comment">//该平衡树的模板根据题意重构了，部分注释可能不对，为模板原来的注释</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scapegoat</span>&#123;</span><br><span class="line">    <span class="comment">//该模板的BST，左侧子节点的值小于等于当前节点的值</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.75</span>;    <span class="comment">//替罪羊树的不平衡度，通常在0.7左右</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> ls, rs;</span><br><span class="line">        T val;</span><br><span class="line">        T id;</span><br><span class="line">        T maxn;</span><br><span class="line">        <span class="type">int</span> tot;    <span class="comment">//实际存储的空间，包括删除的节点</span></span><br><span class="line">        <span class="type">int</span> size;   <span class="comment">//实际存储的节点，不包括删除的节点</span></span><br><span class="line">        <span class="type">int</span> save;   <span class="comment">//该节点是否存活，1存活，0删除</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Node&gt; tree;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; order; <span class="comment">//用来记录中序遍历的结果</span></span><br><span class="line">    <span class="type">int</span> cnt;    <span class="comment">//使用数组模拟，vector当数组用减小常数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tree_stack;    <span class="comment">//记录可用空间的栈</span></span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">//tree_stack 的栈顶</span></span><br><span class="line">    <span class="type">int</span> root;   <span class="comment">//当前的根节点，替罪羊树中根节点会变动</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;    <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!u)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Inorder</span>(tree[u].ls);</span><br><span class="line">        <span class="keyword">if</span>(tree[u].save)</span><br><span class="line">            order[++cnt] = u;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree_stack[++top] = u;</span><br><span class="line">        <span class="built_in">Inorder</span>(tree[u].rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Initnode</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        tree[u].ls = tree[u].rs = <span class="number">0</span>;</span><br><span class="line">        tree[u].size = tree[u].tot = tree[u].save = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        tree[u].size = tree[tree[u].ls].size + tree[tree[u].rs].size + tree[u].save;   <span class="comment">//注意这里是1，需要保证u存活</span></span><br><span class="line">        tree[u].tot = tree[tree[u].ls].tot + tree[tree[u].rs].tot + <span class="number">1</span>;</span><br><span class="line">        tree[u].maxn = std::<span class="built_in">max</span>(&#123;tree[u].val, tree[tree[u].ls].maxn, tree[tree[u].rs].maxn&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; u)</span></span>&#123;   <span class="comment">//注意这里的u是引用</span></span><br><span class="line">        rebuild_num++;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        u = order[mid];</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="built_in">Initnode</span>(u);</span><br><span class="line">            tree[u].maxn = tree[u].val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; mid)</span><br><span class="line">            <span class="built_in">build</span>(l, mid - <span class="number">1</span>, tree[u].ls);</span><br><span class="line">        <span class="keyword">if</span>(l == mid)</span><br><span class="line">            tree[u].ls = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">build</span>(mid + <span class="number">1</span>, r, tree[u].rs);</span><br><span class="line">        <span class="built_in">Update</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span>&amp; u)</span></span>&#123;   <span class="comment">//重建函数，调用中序遍历的结果进行构建</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Inorder</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(cnt)</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">1</span>, cnt, u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">notbalance</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若一颗子树的占比超过了平衡率则不平衡</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="type">double</span>) tree[u].size * alpha &lt;= (<span class="type">double</span>) std::<span class="built_in">max</span>(tree[tree[u].ls].size, tree[tree[u].rs].size))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> rebuild_num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*测试使用</span></span><br><span class="line"><span class="comment">    int deep_timer = 0;</span></span><br><span class="line"><span class="comment">    int max_deep = 0;</span></span><br><span class="line"><span class="comment">    std::vector&lt;int&gt; tree_deep;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void cnt_deep(int u)&#123;</span></span><br><span class="line"><span class="comment">        if(u)&#123;</span></span><br><span class="line"><span class="comment">            tree_deep[u] = ++deep_timer;</span></span><br><span class="line"><span class="comment">            max_deep = std::max(max_deep, tree_deep[u]);</span></span><br><span class="line"><span class="comment">            cnt_deep(tree[u].ls);</span></span><br><span class="line"><span class="comment">            cnt_deep(tree[u].rs);</span></span><br><span class="line"><span class="comment">            deep_timer--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u)&#123;</span><br><span class="line"></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;id = &quot;</span> &lt;&lt; tree[u].id &lt;&lt; <span class="string">&quot;,l = &quot;</span> &lt;&lt; tree[tree[u].ls].id &lt;&lt; <span class="string">&quot;,r = &quot;</span> &lt;&lt; tree[tree[u].rs].id &lt;&lt; endl;</span><br><span class="line">            std::cerr &lt;&lt; tree[tree[u].rs].maxn &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print_tree</span>(tree[u].ls);</span><br><span class="line">            <span class="comment">// if(tree[u].save)</span></span><br><span class="line">            <span class="comment">//     std::cerr &lt;&lt; tree[u].id &lt;&lt; space;</span></span><br><span class="line">            <span class="built_in">print_tree</span>(tree[u].rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;     <span class="comment">//获取第k小的数的值</span></span><br><span class="line">        <span class="type">int</span> u = root;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[u].save &amp;&amp; tree[tree[u].ls].size + <span class="number">1</span> == k)</span><br><span class="line">                <span class="keyword">return</span> tree[u].id;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tree[tree[u].ls].size &gt;= k)</span><br><span class="line">                u = tree[u].ls;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k -= tree[tree[u].ls].size + tree[u].save;</span><br><span class="line">                u = tree[u].rs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree[u].id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span>&amp; u, T x, T id)</span></span>&#123;     <span class="comment">//插入数字x</span></span><br><span class="line">        <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">            u = tree_stack[top--];</span><br><span class="line">            tree[u].val = x;</span><br><span class="line">            tree[u].id = id;</span><br><span class="line">            tree[u].maxn = x;</span><br><span class="line">            <span class="built_in">Initnode</span>(u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tree[u].size++;</span></span><br><span class="line">        <span class="comment">// tree[u].tot++;</span></span><br><span class="line">        <span class="keyword">if</span>(tree[tree[u].rs].size &amp;&amp; tree[tree[u].rs].maxn &gt;= x)</span><br><span class="line">            <span class="built_in">Insert</span>(tree[u].rs, x, id);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[u].save &amp;&amp; tree[u].val &gt;= x)</span><br><span class="line">            <span class="built_in">Insert</span>(tree[u].rs, x, id);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">Insert</span>(tree[u].ls, x, id);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Update</span>(u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">notbalance</span>(u))</span><br><span class="line">            <span class="built_in">rebuild</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(T x, T id)</span></span>&#123;</span><br><span class="line">        <span class="built_in">Insert</span>(root, x, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Del_k</span><span class="params">(<span class="type">int</span>&amp; u, <span class="type">int</span> k)</span></span>&#123;      <span class="comment">//删除第k大的数(直接使用不会触发重构，会有问题，需要手动控制重构)</span></span><br><span class="line">        <span class="comment">//tree[u].size--;</span></span><br><span class="line">        <span class="keyword">if</span>(tree[u].save &amp;&amp; tree[tree[u].ls].size + <span class="number">1</span> == k)&#123;</span><br><span class="line">            tree[u].save = <span class="number">0</span>;</span><br><span class="line">            tree[u].val = <span class="number">0</span>;</span><br><span class="line">            tree[u].maxn = <span class="number">0</span>;</span><br><span class="line">            tree[u].id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">Update</span>(u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[tree[u].ls].size + tree[u].save &gt;= k)</span><br><span class="line">            <span class="built_in">Del_k</span>(tree[u].ls, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">Del_k</span>(tree[u].rs, k - tree[tree[u].ls].size - tree[u].save);</span><br><span class="line">        <span class="built_in">Update</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Del</span><span class="params">()</span></span>&#123; <span class="comment">//删除第一个值</span></span><br><span class="line">        <span class="built_in">Del_k</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(tree[root].tot * alpha &gt;= tree[root].size)</span><br><span class="line">            <span class="built_in">rebuild</span>(root);      <span class="comment">//若删除的节点过多则重构</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Scapegoat</span>(<span class="type">int</span> n, std::vector&lt;<span class="type">int</span>&gt; k)&#123;</span><br><span class="line">        tree.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">Node</span>());</span><br><span class="line">        order.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        tree_stack.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        root = cnt = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            tree_stack[++top] = i;</span><br><span class="line"></span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&amp;)&gt; init = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; u)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">                u = tree_stack[top--];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//std::cerr &lt;&lt; u &lt;&lt; space &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">                tree[u].val = k[mid];</span><br><span class="line">                tree[u].id = mid;</span><br><span class="line">                tree[u].maxn = k[mid];</span><br><span class="line">                <span class="built_in">Initnode</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l &lt; mid)</span><br><span class="line">                <span class="built_in">init</span>(l, mid - <span class="number">1</span>, tree[u].ls);</span><br><span class="line">            <span class="keyword">if</span>(l == mid)</span><br><span class="line">                tree[u].ls = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">init</span>(mid + <span class="number">1</span>, r, tree[u].rs);</span><br><span class="line">            <span class="built_in">Update</span>(u);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">1</span>, k.<span class="built_in">size</span>() - <span class="number">1</span>, root);</span><br><span class="line">        <span class="comment">//tree_deep.resize(n + 1, 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Scapegoat</span>(<span class="type">int</span> n, <span class="type">double</span> new_alpha)&#123;</span><br><span class="line">        alpha = new_alpha;</span><br><span class="line">        tree.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">Node</span>());</span><br><span class="line">        order.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        tree_stack.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        root = cnt = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            tree_stack[++top] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//tree_deep.resize(n + 1, 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">k</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; k[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scp = <span class="built_in">Scapegoat</span>&lt;<span class="type">int</span>&gt;((n + d) + <span class="number">10</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//scp.print_tree(scp.Root());</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">time</span>(d + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ind = scp.<span class="built_in">kth</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; &quot;time &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//scp.print_tree(scp.Root());</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(ind != <span class="number">0</span>);</span><br><span class="line">        scp.<span class="built_in">Del</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[ind])&#123;</span><br><span class="line">            vis[ind] = <span class="literal">true</span>;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + s[ind] &lt;= d)&#123;</span><br><span class="line">            time[i + s[ind]].<span class="built_in">push_back</span>(ind);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(time[i].<span class="built_in">begin</span>(), time[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[a] &lt; s[b];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : time[i])&#123;</span><br><span class="line">            scp.<span class="built_in">Insert</span>(k[x], x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt == n)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; (ans == <span class="number">0</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>模拟实现</tag>
        <tag>cf2500</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1969E E. Unique Array题解</title>
    <url>/2025/08/23/CF1969E-E-Unique-Array%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Unique-Array"><a href="#E-Unique-Array" class="headerlink" title="E. Unique Array"></a><a href="https://codeforces.com/contest/1969/problem/E">E. Unique Array</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的数组，一个子段被称为独特的，当且仅当子段中存在一个元素只出现了一次。我们可以进行一种操作选择数组中的任意一个元素将其替换成任意数字。我们需要输出我们最少需要进行几次操作可以使得数组中的所有子段都是独特子段。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们容易想到一个O(n ^ 2 * lgn)的解法我们可以暴力的处理除所有不好的子段，根据我们操作的性质容易发现我们只要对子段中任意一个元素进行操作我们就一定可以使得包含这个元素的子段独特，于是问题转换成了一些区间，我们要选择最少数量的点，满足每个区间中至少包含一个节点。这是一个经典的贪心问题，我们直接按左端点或右端点排序，顺着贪心的取最边界的点即可。</p>
<p>​	我们发现实际上有效的区间数量实际上是不超过n个的，因为所有完全覆盖了某个区间的区间都是没有意义的，于是我们可以考虑处理出每个左端点对应的最小的不独特的区间，考虑如何处理出这些区间。我们可以对每个位置的数处理出其下一个相同的数的位置，我们枚举每个左端点，初始将所有的数的第一个进行区间[x, nxt[x] - 1] + 1的操作，这意味着从x到nxt[x] - 1被我们标记了，是不可以选择的右端点，因为其是独特的，我们找到（i，n）的最小的右端点，满足其元素为0即可，我们可以通过线段树维护最小值和最小值的下标来实现。处理出所有的区间后按照之前所述的贪心策略求最小点即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T pos;</span><br><span class="line">        T minn;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.minn = std::<span class="built_in">min</span>(a.minn, b.minn);</span><br><span class="line">        res.pos = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.minn == res.minn)</span><br><span class="line">            res.pos = std::<span class="built_in">min</span>(res.pos, a.pos);</span><br><span class="line">        <span class="keyword">if</span>(b.minn == res.minn)</span><br><span class="line">            res.pos = std::<span class="built_in">min</span>(res.pos, b.pos);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].minn = <span class="number">0</span>;</span><br><span class="line">            tree[p].pos = pl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        p.minn += d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i];</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        nxt[i] = last[cur[i]];</span><br><span class="line">        last[cur[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(last[i] != n + <span class="number">1</span>)&#123;</span><br><span class="line">            seg.<span class="built_in">update</span>(last[i], nxt[last[i]] - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = seg.<span class="built_in">query</span>(i, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.minn == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;i, p.pos&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">update</span>(i, nxt[i] - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nxt[i] != n + <span class="number">1</span>)</span><br><span class="line">            seg.<span class="built_in">update</span>(nxt[i], nxt[nxt[i]] - <span class="number">1</span>, <span class="number">1</span>);            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.ff &lt;= ls)&#123;</span><br><span class="line">            ls = std::<span class="built_in">min</span>(ls, p.ss);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">        ls = p.ss;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>cf2400</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1979E E. Manhattan Triangle题解</title>
    <url>/2025/08/23/CF1979E-E-Manhattan-Triangle%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Manhattan-Triangle"><a href="#E-Manhattan-Triangle" class="headerlink" title="E. Manhattan Triangle"></a><a href="https://codeforces.com/contest/1979/problem/E">E. Manhattan Triangle</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们n个二维平面上的不同的点，我们要挑出三个点使得这三个点构成一个等边三角形边长为d（保证d是偶数），注意这里等边的边长意义是在曼哈顿距离下的。输出挑选哪三个点，无解输出0，0，0。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们容易根据曼哈顿距离的定义发现对于某个点而言，距离它为d的点围成了一个菱形，同时因为三角形的性质，在曼哈顿意义下的等边三角形总有一条边是在斜率为1的线段上的（这里可以通过画图加以发现理解）。所以我们可以考虑枚举一个节点，然后考虑另外两个节点在斜率为1的线段上，我们x从小到大枚举，通过维护[x - d, x] 与 [x, x + d]的斜率为1或-1上的点来进行快速的判断是否存在我们当前点菱形四线段上间距为d的点对，这里只用考虑同一个线段上的点对即可，因为上面曼哈顿意义下等边的性质。具体维护我采用了map套set实现，标记线段归属的斜率和初相我使用x + y, x - y来进行标识。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cur</span>(n + <span class="number">1</span>);</span><br><span class="line">    std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; ind;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line">        ind[&#123;cur[i].ff, cur[i].ss&#125;] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangx_d;    <span class="comment">//记录从x-d到x的斜率为1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiax_d;    <span class="comment">//记录从x-d到x的斜率为-1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangaddd; <span class="comment">//记录从x到x + d的斜率为1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiaaddd;   <span class="comment">//记录从x到x + d的斜率为-1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    </span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangx_dp;    <span class="comment">//记录从x-d到x的斜率为1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiax_dp;    <span class="comment">//记录从x-d到x的斜率为-1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangadddp; <span class="comment">//记录从x到x + d的斜率为1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiaadddp;   <span class="comment">//记录从x到x + d的斜率为-1的线段,存在距离为d的点的情况</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(cur.<span class="built_in">begin</span>() + <span class="number">1</span>, cur.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = cur[i].ff;</span><br><span class="line">        <span class="type">int</span> y = cur[i].ss;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右侧拓展</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt;= n &amp;&amp; cur[right].ff &lt;= x + d)&#123;</span><br><span class="line">            <span class="type">int</span> xn = cur[right].ff;</span><br><span class="line">            <span class="type">int</span> yn = cur[right].ss;</span><br><span class="line">            shangadddp[xn - yn].<span class="built_in">insert</span>(&#123;xn, yn&#125;);</span><br><span class="line">            xiaadddp[xn + yn].<span class="built_in">insert</span>(&#123;xn, yn&#125;);</span><br><span class="line">            <span class="keyword">if</span>(shangadddp[xn - yn].<span class="built_in">count</span>(&#123;xn -  d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                shangaddd[xn - yn].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(xiaadddp[xn + yn].<span class="built_in">count</span>(&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                xiaaddd[xn + yn].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            right += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左侧删除</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= i &amp;&amp; cur[left].ff &lt; x - d)&#123;</span><br><span class="line">            <span class="type">int</span> xn = cur[left].ff;</span><br><span class="line">            <span class="type">int</span> yn = cur[left].ss;</span><br><span class="line">            shangx_dp[xn - yn].<span class="built_in">erase</span>(&#123;xn, yn&#125;);</span><br><span class="line">            xiax_dp[xn + yn].<span class="built_in">erase</span>(&#123;xn, yn&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shangx_dp[xn - yn].<span class="built_in">count</span>(&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);  </span><br><span class="line">                shangx_d[xn - yn].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(xiax_dp[xn + yn].<span class="built_in">count</span>(&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);  </span><br><span class="line">                xiax_d[xn + yn].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左侧拓展</span></span><br><span class="line">        shangx_dp[x - y].<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">        xiax_dp[x + y].<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(shangx_dp[x - y].<span class="built_in">count</span>(&#123;x -  d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            shangx_d[x - y].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xiax_dp[x + y].<span class="built_in">count</span>(&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            xiax_d[x + y].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取是否存在匹配</span></span><br><span class="line">        <span class="type">int</span> needx = x + d;</span><br><span class="line">        <span class="type">int</span> needy = y;</span><br><span class="line">        <span class="keyword">if</span>(!shangaddd[needx - needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *shangaddd[needx - needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!xiaaddd[needx + needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *xiaaddd[needx + needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        needx = x - d;</span><br><span class="line">        needy = y;</span><br><span class="line">        <span class="keyword">if</span>(!shangx_d[needx - needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *shangx_d[needx - needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!xiax_d[needx + needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *xiax_d[needx + needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右侧删除</span></span><br><span class="line">        shangadddp[x - y].<span class="built_in">erase</span>(&#123;x, y&#125;);</span><br><span class="line">        xiaadddp[x + y].<span class="built_in">erase</span>(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(shangadddp[x - y].<span class="built_in">count</span>(&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            shangaddd[x - y].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xiaadddp[x + y].<span class="built_in">count</span>(&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            xiaaddd[x + y].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">0</span> &lt;&lt; space &lt;&lt; <span class="number">0</span> &lt;&lt; space &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>模拟实现</tag>
        <tag>cf2400</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1981D D. Turtle and Multiplication 题解</title>
    <url>/2025/08/21/CF1981D-D-Turtle-and-Multiplication-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D-Turtle-and-Multiplication"><a href="#D-Turtle-and-Multiplication" class="headerlink" title="D. Turtle and Multiplication"></a><a href="https://codeforces.com/contest/1981/problem/D">D. Turtle and Multiplication</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个数字n，我们需要构造一个长度为n的数组，满足以下条件，数组中的所有元素属于[1, 3e5]，数组中没有两个相邻的元素的乘积相同，数组中不同的数的种类是长度为n下所有合法数组中最小的。输出任意一个符合条件的解。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先考虑如何在保证没有相邻元素的乘积相同的同时使得数组中不同种类的数的个数最小，我们发现我们选择所有不同的素数来构成数组一定是最优的，因为素数的性质保证了只要相邻两个元素的组成不同乘积就不同，不会出现2 * 6 &#x3D;&#x3D; 3 * 4这样的情况。x个数组可以组成 （x * (x + 1) ) &#x2F; 2种不同的组合。我们发现如果从图论的角度抽象这个问题，把不同的两两组合看作两个节点之间的边，那么问题就变成了从这张图中找出一个长度为n的欧拉路，注意到当need（需要的最少素数个数）为奇数时，图一定存在欧拉回路，need为偶数时图中不存在走完所有边的欧拉路，此时我们最少要删除（need - 2）&#x2F; 2条边才可以得到一个可以走完所有边的欧拉路，这也就是need个素数时可以产生的最大贡献。</p>
<p>​	通过素数筛法我们发现3e5范围内的素数是够用的，我们直接全部用素数构造数组即可，找到最小需要的素数数量，然后构建一个这几个素数的完全图，如果need为偶数时3 - 4 ，5 - 6， 7 - 8…这些边去掉，最后就可以保证欧拉路的存在。然后我们找出从1节点开始的欧拉路即可，此时一定可以包含图中所有边，我们输出前n - 1条边组成的节点即可得到长度为n的数组，且一定满足数组的需求定义。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; minp, primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    minp.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    primes.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            minp[i] = i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            minp[i * p] = p;</span><br><span class="line">            <span class="keyword">if</span> (p == minp[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e7</span>;  <span class="comment">//无向边需要开两倍</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> nex;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].from = u;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].nex = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> need = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2e3</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> all = (i * (<span class="number">1</span> + i)) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            all -= (i - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(all + <span class="number">1</span> &gt;= n)&#123;</span><br><span class="line">            need = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> all = (need * (<span class="number">1</span> + need)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        all -= (need - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(<span class="number">1</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= need; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= need; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">1</span> &amp;&amp; i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; j == i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            edge.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            <span class="built_in">add</span>(i, j);</span><br><span class="line">            <span class="built_in">add</span>(j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">use</span><span class="params">(cnt + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> node) -&gt; <span class="type">void</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now = head[node]; now &gt; <span class="number">0</span>; now = head[node])&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(use[now])&#123;</span><br><span class="line">                head[node] = e[now].nex;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            use[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">                use[now ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            head[node] = e[now].nex;    <span class="comment">//删去遍历过的点</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dfs</span>(e[now].to);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ind = (t == <span class="number">1</span> ? now / <span class="number">2</span> : now - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span> &amp;&amp; now % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(ind);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(-ind);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(ind); <span class="comment">//注意对于有向图我们这里实际是找到的逆的路径，所以不用-ind</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(edge[ans[i]].ff);</span><br><span class="line">            res.<span class="built_in">push_back</span>(edge[ans[i]].ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(edge[-ans[i]].ss);</span><br><span class="line">            res.<span class="built_in">push_back</span>(edge[-ans[i]].ff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; primes[res[i]] &lt;&lt; sendl[i == n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= need; i++)</span><br><span class="line">        head[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2400</tag>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>欧拉路/回路</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2063F1 F1. Counting Is Not Fun (Easy Version)题解</title>
    <url>/2025/08/21/CF2063F1-F1-Counting-Is-Not-Fun-Easy-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F1-Counting-Is-Not-Fun-Easy-Version"><a href="#F1-Counting-Is-Not-Fun-Easy-Version" class="headerlink" title="F1. Counting Is Not Fun (Easy Version)"></a><a href="https://codeforces.com/contest/2063/problem/F1">F1. Counting Is Not Fun (Easy Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个数字n，代表一个有着n个好对的括号序列，一个好对（i, j) (i &lt; j) 满足s[i] &#x3D;&#x3D; ‘(‘, s[j] &#x3D;&#x3D; ‘)’同时去掉i，j两个字符，区间内剩余的子串是一个合法的平衡括号字符串，可以证明对于一个长度位2 * n的括号序列一定有n个好对。题目依次给出n个好对，我们需要计算出前i个好对确定的情况下有多少种符号要求的合法括号字符串（i从0到n）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们根据题目的定义我们发现对于一个好对[l, r]其中l - 1， r - 1可以填任何合法的括号序列，所以我们需要预处理出长度x时的合法括号序列数，这可以通过dp[len] [diff]来n ^ 2的dp处理出来，状态表示长度为len时平衡度为diff的括号序列数量。然后考虑如何根据确定了的好对来计算可能的括号序列种类。我们发现一个好对就可以把其包含区间的种类给算出来，并且按照定义好对不会相交，只有可能包含，包含时我们可以用来填的空要是还没有确定的，也就是去掉包含的好对长度，于是对于前i个，我们可以通过维护左端点第一关键，右端点第二关键，有序的好对前缀，来O（n）的计算出每个好对还可以填写的空，结合dp[len] [0]相乘计数即可，最后乘上剩余所有没填的空的贡献即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> N = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span> * N + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (<span class="number">1LL</span> * dp[i][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; N)</span><br><span class="line">                dp[i][j] = (<span class="number">1LL</span> * dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + dp[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cur</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;ll&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(dp[<span class="number">2</span> * n][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">occur</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    cur[<span class="number">0</span>].ff = <span class="number">0</span>;</span><br><span class="line">    cur[<span class="number">0</span>].ss = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ind = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[qu[j]].ff &lt;= cur[i].ff || (cur[qu[j]].ff == cur[i].ff &amp;&amp; cur[qu[j]].ss &lt;= cur[i].ss))&#123;</span><br><span class="line">                ind = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; i &lt;&lt; space &lt;&lt; ind &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= ind; j++)</span><br><span class="line">            now.<span class="built_in">push_back</span>(qu[j]);</span><br><span class="line">        now.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = ind + <span class="number">1</span>; j &lt; qu.<span class="built_in">size</span>(); j++)</span><br><span class="line">            now.<span class="built_in">push_back</span>(qu[j]);</span><br><span class="line">        qu = now;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// for(int j = 0; j &lt; qu.size(); j++)</span></span><br><span class="line">        <span class="comment">//     std::cerr &lt;&lt; qu[j] &lt;&lt; sendl[j == qu.size() - 1];</span></span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            occur[j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ind : qu)&#123;</span><br><span class="line">            <span class="type">int</span> l = cur[ind].ff;</span><br><span class="line">            <span class="type">int</span> r = cur[ind].ss;</span><br><span class="line">            <span class="keyword">while</span>(cur[stk.<span class="built_in">top</span>()].ss &lt; r)</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            occur[stk.<span class="built_in">top</span>()] += r - l + <span class="number">1</span>;</span><br><span class="line">            stk.<span class="built_in">push</span>(ind);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            ll use = <span class="number">2</span> + occur[j];</span><br><span class="line">            ll last = (cur[j].ss - cur[j].ff + <span class="number">1</span>) - use;</span><br><span class="line">            ans = (ans * dp[last][<span class="number">0</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ll last = <span class="number">2</span> * n - occur[<span class="number">0</span>];</span><br><span class="line">        ans = (ans * dp[last][<span class="number">0</span>]) % mod;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; res[i] &lt;&lt; sendl[i == res.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟实现</tag>
        <tag>cf2400</tag>
        <tag>动态规划</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2063F2 F2. Counting Is Not Fun (Hard Version)题解</title>
    <url>/2025/08/21/CF2063F2-F2-Counting-Is-Not-Fun-Hard-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F2-Counting-Is-Not-Fun-Hard-Version"><a href="#F2-Counting-Is-Not-Fun-Hard-Version" class="headerlink" title="F2. Counting Is Not Fun (Hard Version)"></a><a href="https://codeforces.com/contest/2063/problem/F2">F2. Counting Is Not Fun (Hard Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​   题目给我们一个数字n，代表一个有着n个好对的括号序列，一个好对（i, j) (i &lt; j) 满足s[i] &#x3D;&#x3D; ‘(‘, s[j] &#x3D;&#x3D; ‘)’同时去掉i，j两个字符，区间内剩余的子串是一个合法的平衡括号字符串，可以证明对于一个长度位2 * n的括号序列一定有n个好对。题目依次给出n个好对，我们需要计算出前i个好对确定的情况下有多少种符号要求的合法括号字符串（i从0到n）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	与easy版本不同的是hard版的数据到达了3e5，首先我们easy版计算长度为x的合法括号序列的复杂度我们就无法接受，考虑如何快速计算，这实际上就是卡特兰数，我们的平衡度总是大于等于0，最后等于0，相当于不穿过y &#x3D; x，走到（x &#x2F; 2， x &#x2F; 2），我们可以世界使用卡特兰数的组合数学公式来快速计算。</p>
<p>​	接着考虑如何计算每个前缀好对的可能的括号序列数，注意到easy版我们对每个都进行了重新计算，这实际上没有必要，因为我们新加入一个好对只会影响最小的覆盖其的好对，重新计算它的贡献，然后乘上新加入的好对的贡献即可。要知道最小覆盖其的好对我们可以使用一个线段树维护覆盖某个点的长度最小的对的序号即可，这实际上相当于线段树维护最小值。知道某个好对还没被覆盖的点的个数我们可以使用令一个线段树维护区间最小值和这个区间最小值的个数即可，考虑某个好对，覆盖其的好对一定不会计算到其中，之后其中的好对非区间最小值的一定被覆盖了，而区间最小值一定没有被覆盖。我们重新计算新加入好对及覆盖其的好对的贡献即可。</p>
<p>​	本题实际上有一个更为简单的实现，倒着求答案，看作删除一个好对，这相当于把删除的好对和最小覆盖其的好对合并到了一起，抽象成图论可以看作缩点，其覆盖的子好对顺着转移过去即可，使用并查集维护节点，同时维护某个好对覆盖的子对长度和即可简单实现计算。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>; <span class="comment">//注意这里要多开点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line">ll fact[N + <span class="number">1</span>],infact[N + <span class="number">1</span>];   <span class="comment">//  阶乘和阶乘的逆元</span></span><br><span class="line"><span class="comment">//取模版本快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll k, ll m)</span></span>&#123;   <span class="comment">//求a^k mod m</span></span><br><span class="line">    a %= m;</span><br><span class="line">    ll res = <span class="number">1</span> % m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * a % m;<span class="comment">//指数k为1的位乘上a^(1&lt;&lt;x)mod m</span></span><br><span class="line">        a = a * a % m;<span class="comment">//每一项是前一项的平方模m</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n = N)</span></span>&#123; <span class="comment">// 预处理阶乘取模的余数和阶乘取模余数的逆元</span></span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    infact[N] = <span class="built_in">qmi</span>(fact[N], mod - <span class="number">2</span>, mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        infact[i] = infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组合数A和C</span></span><br><span class="line"><span class="comment">//C(a, b) = !a / !(a - b) * !(b)    //a个里挑b个</span></span><br><span class="line"><span class="comment">//A(a, b) = !a / !(a - b)</span></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fact[a] * infact[a-b] % mod * infact[b] % mod;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> fact[a] * infact[a-b] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求逆元</span></span><br><span class="line"><span class="function">ll <span class="title">contary</span><span class="params">(ll now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmi</span>(now, mod - <span class="number">2</span>, mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力计算组合数C</span></span><br><span class="line"><span class="function">ll <span class="title">burteC</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; k || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) ret = ret * (m - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) ret = ret * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getCn</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">C</span>(<span class="number">2</span> * n, n) - <span class="built_in">C</span>(<span class="number">2</span> * n, n - <span class="number">1</span>) + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T minn;</span><br><span class="line">        T val;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.minn = std::<span class="built_in">min</span>(a.minn, b.minn);</span><br><span class="line">        <span class="keyword">if</span>(a.minn == res.minn)</span><br><span class="line">            res.val += a.val;</span><br><span class="line">        <span class="keyword">if</span>(b.minn == res.minn)</span><br><span class="line">            res.val += b.val;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = <span class="number">1</span>;</span><br><span class="line">            tree[p].minn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        p.minn += d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">0</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>((n + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>((n + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeInd</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T minind;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur[a.minind].ss - cur[a.minind].ff &lt;= cur[b.minind].ss - cur[b.minind].ff)</span><br><span class="line">            res = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res = b;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = a[pl];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[p.minind].ss - cur[p.minind].ff &gt;= cur[d].ss - cur[d].ff)</span><br><span class="line">            p.minind = d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[tag[p]].ss - cur[tag[p]].ff &gt;= cur[d].ss - cur[d].ff)</span><br><span class="line">            tag[p] = d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTreeInd</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTreeInd</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    cur.<span class="built_in">assign</span>(n + <span class="number">1</span>, std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;());</span><br><span class="line">    cur[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">2</span> * n + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line">    std::vector&lt;ll&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="built_in">getCn</span>(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> segid = <span class="built_in">SegmentTreeInd</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="built_in">getCn</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ll in = seg.<span class="built_in">query</span>(cur[i].ff, cur[i].ss).val;</span><br><span class="line">        ll need = (in - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        ans = ans * <span class="built_in">getCn</span>(need) % mod;</span><br><span class="line"></span><br><span class="line">        ll fa = segid.<span class="built_in">query</span>(cur[i].ff, cur[i].ff).minind;</span><br><span class="line">        </span><br><span class="line">        ll infa = seg.<span class="built_in">query</span>(cur[fa].ff, cur[fa].ss).val;</span><br><span class="line"></span><br><span class="line">        ll needfa = (infa - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        ll con = <span class="built_in">getCn</span>(needfa);</span><br><span class="line">        ans = ans * <span class="built_in">qmi</span>(con, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">update</span>(cur[i].ff, cur[i].ss, <span class="number">1</span>);</span><br><span class="line">        infa = seg.<span class="built_in">query</span>(cur[fa].ff, cur[fa].ss).val;</span><br><span class="line">        needfa = (infa - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        con = <span class="built_in">getCn</span>(needfa);</span><br><span class="line">        ans = ans * con % mod;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">        segid.<span class="built_in">update</span>(cur[i].ff, cur[i].ss, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; res[i] &lt;&lt; sendl[i == res.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模拟实现</tag>
        <tag>图论</tag>
        <tag>组合数学</tag>
        <tag>cf2700</tag>
        <tag>并查集</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2064E E. Mycraft Sand Sort题解</title>
    <url>/2025/08/04/CF2064E%20E.%20Mycraft%20Sand%20Sort%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Mycraft-Sand-Sort"><a href="#E-Mycraft-Sand-Sort" class="headerlink" title="E. Mycraft Sand Sort"></a><a href="https://codeforces.com/problemset/problem/2064/E">E. Mycraft Sand Sort</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的排列，代表n行沙子，其元素大小就是第i行沙子的长度。题目还给我们一个长度为n的数组，其数组元素的值代表第i行沙子的颜色。最终沙子会因重力而落下，我们要计算初始有多少种排列和颜色的组合可以使得最终沙子落下来的效果与给定的一样，注意对998244353取模。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们通过观察发现本题的一个重要性质，数组的颜色数组是不会发生改变的，因为每一行的沙子的长度都大于等于1。所以第一格的元素的颜色就把整个数组的颜色给定了下来。并且长度为i的沙子是什么颜色也不会改变，所以方案数会增多就来源于同色的沙子之间的交换。我们发现对于颜色相同的第x行和第y行沙子可以交换的条件是沙子x和y之间不存在比其长度最小值大的异色沙子行，我们可以使用并查集和链表，从长度最小的沙子行开始考虑交换维护这个过程计算答案。</p>
<p>​	注意这里有一个误区，用并查集从小到大合并之后阶乘计算贡献是错误的，其并不可以保证我们的交换条件合法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">len</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; len[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; col[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> dsu = <span class="built_in">DSU</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">R</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[i] == col[i - <span class="number">1</span>])</span><br><span class="line">            dsu.<span class="built_in">merge</span>(i, i - <span class="number">1</span>);</span><br><span class="line">        L[i] = i - <span class="number">1</span>;</span><br><span class="line">        R[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">op</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        op[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(op.<span class="built_in">begin</span>(), op.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> len[a] &lt; len[b];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos : op)&#123;</span><br><span class="line"></span><br><span class="line">        ans = (ans * dsu.<span class="built_in">size</span>(pos)) % mod;</span><br><span class="line">        dsu.siz[dsu.<span class="built_in">find</span>(pos)] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dsu.<span class="built_in">size</span>(pos) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(col[L[pos]] == col[R[pos]] &amp;&amp; col[R[pos]] != <span class="number">0</span>)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(L[pos], R[pos]);</span><br><span class="line"></span><br><span class="line">        R[L[pos]] = R[pos];</span><br><span class="line">        L[R[pos]] = L[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>cf2400</tag>
      </tags>
  </entry>
  <entry>
    <title>arc203_d D - Insert XOR题解</title>
    <url>/2025/08/22/arc203-d-D-Insert-XOR%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D-Insert-XOR"><a href="#D-Insert-XOR" class="headerlink" title="D - Insert XOR"></a><a href="https://atcoder.jp/contests/arc203/tasks/arc203_d"><strong>D - Insert XOR</strong></a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的二进制字符串，我们要处理q次操作，每次操作给我们一个pos，我们会翻转s[pos]，我们每次操作后都要输出当前字符串的最小代价，操作是持久化的。一个二进制字符串的代价为需要的最小的初始字符串长度，使得我们可以通过对这个初始字符串进行若干次操作来得到当前字符串，我们可以进行的操作是选择两个相邻的字符元素，在其中间插入两个数异或的结果。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	我们考虑代价时从当前数组删减到最小的字符串长度来考虑会更容易，首先我们发现我们需要特判掉全部为1的情况，此时需要的初始字符串一定长度为n，然后剩余的情况我们可以进行的删减实际上就三种情况</p>
<pre><code>	1. 11 -&gt; 1 (要求当前字符串中存在0) 2. 000 -&gt; 00 (无要求) 3. 101 -&gt; 1 (要求当前字符串除这个对还存在0)
</code></pre>
<p>​    我们考虑吧维护每个元素对答案减小的贡献，则此时cur[i] &#x3D;&#x3D; 1 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 1, 此时位置i贡献为1，cur[i] &#x3D;&#x3D; 0 &amp;&amp; cur[i + 1] &#x3D;&#x3D; 0 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 0,此时位置i贡献为1，cur[i] &#x3D;&#x3D; 0 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 1 &amp;&amp; cur[i + 1] &#x3D;&#x3D; 1,此时位置i的贡献为2，我们最后的答案就是n - 贡献和，注意答案为1时实际上要特判成2，因为我们不可能缩到1，再特判掉全1的情况即可，上面三种贡献实际上和三种删减情况一一对应。本题还有实现起来较为麻烦的线段树解法，我们直接用线段树维护区间的删减情况进行合并即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(n + <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">1</span>)</span><br><span class="line">            cnt1 += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">1</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">0</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[i + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">0</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[i + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> getans = [&amp;]()&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == n)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="number">2</span>, n - sum);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> del = [&amp;](<span class="type">int</span> pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span>)</span><br><span class="line">            cnt1 -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum -= <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span>)</span><br><span class="line">            cnt1 += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pos;</span><br><span class="line">        std::cin &gt;&gt; pos;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">del</span>(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">del</span>(pos);</span><br><span class="line">        <span class="built_in">del</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cur[pos] ^= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(pos);</span><br><span class="line">        <span class="built_in">add</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">getans</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>atcoder2400</tag>
      </tags>
  </entry>
  <entry>
    <title>李超线段树模板(class)</title>
    <url>/2025/08/07/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF-class/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ShadowDrunk</span></span><br><span class="line"><span class="comment">//李超线段树实际上是维护在二维坐标系上插入线段，同时查询x == d时y最大的线段是哪个以及对应的值的变式线段树</span></span><br><span class="line"><span class="comment">//我们发现一个线段可以看作作用域在[x0, x1]上的一次函数，我们维护函数即可</span></span><br><span class="line"><span class="comment">//我们给每个节点打上标记用于懒操作，每个标记都是一个完全覆盖当前区间的线段</span></span><br><span class="line"><span class="comment">//当我们插入一个线段时我们把它拆分到其包含的所有区间去考虑它的影响</span></span><br><span class="line"><span class="comment">//考虑当前插入线段对其覆盖区间的影响，将当前线段和之前标记线段在mid处更优秀的留做懒标记</span></span><br><span class="line"><span class="comment">//mid处更劣的线段看在两边是否和更优线段存在交点</span></span><br><span class="line"><span class="comment">//显然最多左边或右边，有且只有一边可能存在交点，我们把更劣的线段递归下传继续考虑</span></span><br><span class="line"><span class="comment">//在处理查询时我们类似于标记永久化的思想遍历包含的所有节点（包含路径中的节点），取所有节点标记的线段中最优的</span></span><br><span class="line"><span class="comment">//这是因为我们标记的线段一定是最优的或是最优的是其父亲节点中的标记，但还没有下传，我们遍历了所有路径节点，最优线段一定在其中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiSegTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//李超线段树</span></span><br><span class="line"><span class="comment">//该模板维护的是线段对应k点最大的y归属于哪个序号最小的线段</span></span><br><span class="line"><span class="comment">//若需要修改成y最小需要修改用pmin以及改change内部的比较逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改O(lgn * lgn), 查询O(lgn)</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//x轴值域[1, n]</span></span><br><span class="line">    <span class="type">int</span> m;  <span class="comment">//插入的线段的最大数量</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回x与y的大小关系，1则x大，0相等，-1则y大</span></span><br><span class="line">        <span class="keyword">if</span>(x - y &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y - x &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">        <span class="comment">//记录线段斜率和截距</span></span><br><span class="line">        <span class="type">double</span> k, b;</span><br><span class="line">        <span class="built_in">line</span>(<span class="type">double</span> _k, <span class="type">double</span> _b)&#123;</span><br><span class="line">            k = _k; b = _b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">line</span>()&#123;</span><br><span class="line">            k = <span class="number">0</span>; b = -inf;</span><br><span class="line">            <span class="comment">//b == inf; //维护y最小时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;line&gt; p;    <span class="comment">//记录插入的线段</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//内部线段的数量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tag; <span class="comment">//记录区间标记属于哪个线段, 每个标记都是一个线段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> id, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算id对应线段在x == d时的值</span></span><br><span class="line">        <span class="keyword">return</span>  p[id].b + p[id].k * d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="comment">//插入线段, (x0, y0), (x1, y1) 为线段两个端点</span></span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x0 == x1)&#123;</span><br><span class="line">            p[cnt].k = <span class="number">0</span>;</span><br><span class="line">            p[cnt].b = std::<span class="built_in">max</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p[cnt].k = <span class="number">1.0</span> * (y1 - y0) / (x1 - x0);</span><br><span class="line">            p[cnt].b = y0 - p[cnt].k * x0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> root, T pl, T pr, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改被完全覆盖的区间的标记</span></span><br><span class="line">        <span class="type">int</span> &amp;v = tag[root];</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bmid = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, mid), <span class="built_in">calc</span>(v, mid));</span><br><span class="line">        <span class="keyword">if</span>(bmid == <span class="number">1</span> || (!bmid &amp;&amp; u &lt; v))</span><br><span class="line">            std::<span class="built_in">swap</span>(u, v);    <span class="comment">//确保u线段在mid处小于等于v线段</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bl = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pl), <span class="built_in">calc</span>(v, pl));</span><br><span class="line">        <span class="type">int</span> br = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pr), <span class="built_in">calc</span>(v, pr));</span><br><span class="line">        <span class="comment">//判断那边的区间存在交点</span></span><br><span class="line">        <span class="keyword">if</span>(bl == <span class="number">1</span> || (!bl &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, u);</span><br><span class="line">        <span class="keyword">if</span>(br == <span class="number">1</span> || (!br &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, u);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面两个if最多只会触发一个这保证了修改的复杂度</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //y最小代码</span></span><br><span class="line"><span class="comment">            if(bmid == -1 || (!bmid &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                std::swap(u, v);    //确保u线段在mid处大于等于v线段</span></span><br><span class="line"><span class="comment">            if(bl == -1 || (!bl &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change(root &lt;&lt; 1, pl, mid, u);</span></span><br><span class="line"><span class="comment">            if(br == -1 || (!br &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change((root &lt;&lt; 1) | 1, mid + 1, pr, u);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> root, T pl, T pr, T l, T r, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= pl &amp;&amp; pr &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">change</span>(root, pl, pr, u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, l, r, u);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, l, r, u); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmax</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmin</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> root, T l, T r, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询x == d时的答案</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt; d || l &gt; d)</span><br><span class="line">            <span class="keyword">return</span> &#123;-inf, <span class="number">0</span>&#125;;  <span class="comment">//维护y最小 return &#123;inf, 0&#125;;</span></span><br><span class="line">        T mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="built_in">calc</span>(tag[root], d);</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> &#123;res, tag[root]&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, tag[root]&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(root &lt;&lt; <span class="number">1</span>, l, mid, d),</span><br><span class="line">        <span class="built_in">query</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, d)));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //维护y最小时使用</span></span><br><span class="line"><span class="comment">            return pmin(&#123;res, s[root]&#125;, pmin(query(root &lt;&lt; 1, l, mid, d),</span></span><br><span class="line"><span class="comment">            query((root &lt;&lt; 1) | 1, mid + 1, r, d)));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addline</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x0 &gt; x1)&#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(x0, x1);</span><br><span class="line">            std::<span class="built_in">swap</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(x0, y0, x1, y1);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x0, x1, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>(<span class="type">int</span> _n, <span class="type">int</span> _m)&#123;</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>()&#123;</span><br><span class="line">        n = <span class="number">5e5</span>, m = <span class="number">5e5</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
</search>
