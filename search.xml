<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>unity中c#实现常见3D ACT 游戏主角镜头控制</title>
    <url>/2025/12/01/unity%E4%B8%ADc-%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%813D-ACT-%E6%B8%B8%E6%88%8F%E4%B8%BB%E8%A7%92%E9%95%9C%E5%A4%B4%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="unity中c-实现常见3D-ACT-游戏主角镜头控制"><a href="#unity中c-实现常见3D-ACT-游戏主角镜头控制" class="headerlink" title="unity中c#实现常见3D ACT 游戏主角镜头控制"></a>unity中c#实现常见3D ACT 游戏主角镜头控制</h2><p>​	首先需要明确这个镜头需要完成的工作(我实现的这个摄像机镜头逻辑是参考鸣潮在游戏中的表现实现的):</p>
<p>​		1.可以根据鼠标的左右上下滚动滚动视野,随鼠标滚轮缩放视野</p>
<p>​		2.防止出现摄像机穿模,摄像机不可以位于地面地下,同时摄像机不可以位于障碍中</p>
<p>​	同时需要实现配合相机的主角的基本移动方式,通常wasd代表前左下右的移动,这个方向是相对于摄像机器,所以通过RigidBody控制主角速度时速度方向的计算要结合摄像机。</p>
<p>​	我们还可以加入act常见的隐藏光标来优化游戏的表现，本脚本默认隐藏鼠标的光标，按ctrl会呼出鼠标的光标。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>​	首先是基础逻辑部分，相机的缩放和视野球状滚动，我们需要下面的基础数据。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Header(<span class="string">&quot;目标与基础设置&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> Transform target;    <span class="comment">//主角的transform</span></span><br><span class="line"><span class="keyword">public</span> Vector3 offset = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">-5</span>);  <span class="comment">//初始相对偏移</span></span><br><span class="line"><span class="keyword">public</span> LayerMask obstacleLayer; <span class="comment">// 障碍物层</span></span><br><span class="line"><span class="keyword">public</span> LayerMask groundLayer; <span class="comment">// 障碍物层</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="meta">Header(<span class="string">&quot;旋转设置&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> rotateSpeed = <span class="number">2f</span>;		<span class="comment">//相机x轴，y轴旋转灵敏度，常见实现中应该分成两个变量设计，这里偷懒了</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> minXAngle = <span class="number">-80f</span>; <span class="comment">// 相机向下最大角度</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> maxXAngle = <span class="number">80f</span>;  <span class="comment">// 相机向上最大角度</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">Header(<span class="string">&quot;距离设置&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> minDistance = <span class="number">2f</span>;	<span class="comment">//相机缩放的最小距离</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> maxDistance = <span class="number">10f</span>;	<span class="comment">//相机缩放最大距离</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> scrollSpeed = <span class="number">2f</span>;	<span class="comment">//缩放灵敏度</span></span><br></pre></td></tr></table></figure>

<p>​	使用target获取主角的Transform引用，用来锚定相机的球心，offset用来标记相机的初始相对偏移位置，对于主角y坐标上偏移2个世界单位，z坐标-5个世界单位。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    currentDistance = offset.magnitude;</span><br><span class="line">    Vector3 angles = transform.eulerAngles;</span><br><span class="line">    currentX = angles.y;</span><br><span class="line">    currentY = angles.x;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>​	上面是初始化的代码,我们根据默认偏移offset计算出我们目前的x轴和y轴的旋转量，注意这里的旋转量的x，y是便于我们理解的x，y。在unity中y的旋转实际上是关于x轴的，所以只有将欧拉角转换为四元数时需要把currentX放到x轴的旋转量中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    currentX += Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>) * rotateSpeed;</span><br><span class="line">    currentY += Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>) * rotateSpeed;</span><br><span class="line">    currentY = Mathf.Clamp(currentY, minXAngle, maxXAngle); <span class="comment">// 限制垂直角度</span></span><br><span class="line">    currentX %= <span class="number">360f</span>;</span><br><span class="line">   </span><br><span class="line">    currentDistance -= Input.GetAxis(<span class="string">&quot;Mouse ScrollWheel&quot;</span>) * scrollSpeed;</span><br><span class="line">    currentDistance = Mathf.Clamp(currentDistance, minDistance, maxDistance);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    Quaternion rotation = Quaternion.Euler(currentY, currentX, <span class="number">0</span>);</span><br><span class="line">    Vector3 direction = rotation * Vector3.forward;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Vector3 desiredPosition = target.position + direction.normalized * currentDistance;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> safeDistance = currentDistance;</span><br><span class="line">    Vector3 safePosition = target.position + direction.normalized * safeDistance;</span><br><span class="line">    transform.position = safePosition;</span><br><span class="line">    transform.LookAt(target.position + Vector3.up * <span class="number">0.5f</span>); <span class="comment">// 看向角色头部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	改段落代码是基础的实现计算相机相对坐标的逻辑，我们通过获取鼠标的x轴移动和y轴移动来计算当前应该的相对滚动的角度偏移，注意y轴的移动量我们需要在最小偏移和最大偏移之间。x轴的偏转最好对360取模，通过获取鼠标滚轮的输入来取得缩放的变化，缩放我们是通过维护一个距离角色的球面的距离，来实现缩放效果。注意rotation的计算，我们将currentX，currentY转化成四元数时的x轴旋转量放的是currentY,y轴旋转量是currentX。然后通过rotation * Vector3.forward就可以获取到相机相对于角色的偏转方向向量（注意这里一定要是Vector3.forward, 因为我们计算的四元数偏转是相对于世界方向正前方的)。</p>
<p>​	safePositon就是我们计算出来的相机位置，在让他看向角色的头顶就完成了基本的相机位置随鼠标移动，注意0.5f这个偏移根据角色的身高需要我们自己调整。</p>
<h3 id="碰撞和防穿地检测"><a href="#碰撞和防穿地检测" class="headerlink" title="碰撞和防穿地检测"></a>碰撞和防穿地检测</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> safeDistance = currentDistance;</span><br><span class="line">Vector3 safePosition = target.position + direction.normalized * safeDistance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; maxCheckIterations; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Collider[] colliders = Physics.OverlapSphere(safePosition, cameraCheckRadius, obstacleLayer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防穿地检测</span></span><br><span class="line">    Vector3 rayStart = target.position + Vector3.up * <span class="number">0.5f</span>;</span><br><span class="line">    <span class="built_in">bool</span> checkGround = Physics.Raycast(rayStart, direction.normalized, safeDistance, groundLayer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (colliders.Length == <span class="number">0</span> &amp;&amp; (!checkGround)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    safeDistance -= (currentDistance - minDistance) / maxCheckIterations; <span class="comment">// 均匀缩小</span></span><br><span class="line">    safePosition = target.position + direction.normalized * safeDistance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里要使用线性插值，防止连续障碍物，碰撞检测得到的安全位置偏差过大引起画面抖动</span></span><br><span class="line"><span class="built_in">float</span> realDistance = (transform.position - target.position).magnitude;</span><br><span class="line">realDistance = Mathf.Lerp(realDistance, safeDistance, smoothSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有发生碰撞检测直接跳跃</span></span><br><span class="line"><span class="keyword">if</span> (safeDistance == currentDistance) realDistance = currentDistance;</span><br><span class="line"></span><br><span class="line">Vector3 finalPosition = target.position + direction.normalized * realDistance;</span><br><span class="line"></span><br><span class="line">transform.position = finalPosition;</span><br><span class="line">transform.LookAt(target.position + Vector3.up * <span class="number">0.5f</span>); <span class="comment">// 看向角色头部</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	将上文中计算出safePosition之后的内容全部改成上面的内容就完成了相机的碰撞和防穿地检测，我们根据计算出的safePosition做球体检测，直到相机的虚拟球形碰撞体没有碰撞的物品，并且相机于角色之间形成的线段不存在地面。我们找safePosition的过程就是暴力的缩短safeDistance来进行尝试，我设置的尝试次数maxCheckIterations为10。因为是参考模仿的鸣潮的摄像机运转，碰撞检测是不会改变currentDistance的，这意味着脱离碰撞后我们的摄像机会直接移动到一个之前滚轮滚到的缩放状态。</p>
<p>​	同时需要注意我们的当前真实距离realDistance不可以直接修改成safeDistance。如果直接修改会造成连续碰撞的或连续触发穿地检测时会出现Distance的快速变化造成画面抖动的现象，我们速妖使用线性插值来进行优化。同时没有发生碰撞检测时我们可以直接跳转到currentDistance。</p>
<h3 id="完整相机控制脚本（挂载在摄像机下）"><a href="#完整相机控制脚本（挂载在摄像机下）" class="headerlink" title="完整相机控制脚本（挂载在摄像机下）"></a>完整相机控制脚本（挂载在摄像机下）</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ACTCameraController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;目标与基础设置&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> Transform target;    <span class="comment">//主角的transform</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 offset = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">2</span>, <span class="number">-5</span>);  <span class="comment">//初始相对偏移</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask obstacleLayer; <span class="comment">// 障碍物层</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer; <span class="comment">// 障碍物层</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;旋转设置&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> rotateSpeed = <span class="number">2f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minXAngle = <span class="number">-80f</span>; <span class="comment">// 相机向下最大角度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxXAngle = <span class="number">80f</span>;  <span class="comment">// 相机向上最大角度</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;距离设置&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minDistance = <span class="number">2f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxDistance = <span class="number">10f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> scrollSpeed = <span class="number">2f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> cameraCheckRadius = <span class="number">0.4f</span>; <span class="comment">// 相机检测体积半径（模拟相机大小，需适配场景）</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;优化设置&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maxCheckIterations = <span class="number">10</span>; <span class="comment">// 最大碰撞检测迭代次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> smoothSpeed = <span class="number">10f</span>; <span class="comment">// 位置平滑速度</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 currentVelocity; <span class="comment">// SmoothDamp用的速度缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentX = <span class="number">0</span>;     <span class="comment">//x轴旋转</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentY = <span class="number">0</span>;     <span class="comment">//y轴旋转</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentDistance;  <span class="comment">//相机距离主角的偏移距离</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentDistance = offset.magnitude;</span><br><span class="line">        Vector3 angles = transform.eulerAngles;</span><br><span class="line">        currentX = angles.y;</span><br><span class="line">        currentY = angles.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        currentX += Input.GetAxis(<span class="string">&quot;Mouse X&quot;</span>) * rotateSpeed;</span><br><span class="line">        currentY += Input.GetAxis(<span class="string">&quot;Mouse Y&quot;</span>) * rotateSpeed;</span><br><span class="line">        currentY = Mathf.Clamp(currentY, minXAngle, maxXAngle); <span class="comment">// 限制垂直角度</span></span><br><span class="line">        currentX %= <span class="number">360f</span>;</span><br><span class="line">       </span><br><span class="line">        currentDistance -= Input.GetAxis(<span class="string">&quot;Mouse ScrollWheel&quot;</span>) * scrollSpeed;</span><br><span class="line">        currentDistance = Mathf.Clamp(currentDistance, minDistance, maxDistance);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">        Quaternion rotation = Quaternion.Euler(currentY, currentX, <span class="number">0</span>);</span><br><span class="line">        Vector3 direction = rotation * Vector3.forward;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> safeDistance = currentDistance;</span><br><span class="line">        Vector3 safePosition = target.position + direction.normalized * safeDistance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; maxCheckIterations; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Collider[] colliders = Physics.OverlapSphere(safePosition, cameraCheckRadius, obstacleLayer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//防穿地检测</span></span><br><span class="line">            Vector3 rayStart = target.position + Vector3.up * <span class="number">0.5f</span>;</span><br><span class="line">            <span class="built_in">bool</span> checkGround = Physics.Raycast(rayStart, direction.normalized, safeDistance, groundLayer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colliders.Length == <span class="number">0</span> &amp;&amp; (!checkGround)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            safeDistance -= (currentDistance - minDistance) / maxCheckIterations; <span class="comment">// 均匀缩小</span></span><br><span class="line">            safePosition = target.position + direction.normalized * safeDistance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里要使用线性插值，防止连续障碍物，碰撞检测得到的安全位置偏差过大引起画面抖动</span></span><br><span class="line">        <span class="built_in">float</span> realDistance = (transform.position - target.position).magnitude;</span><br><span class="line">        realDistance = Mathf.Lerp(realDistance, safeDistance, smoothSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有发生碰撞检测直接跳跃</span></span><br><span class="line">        <span class="keyword">if</span> (safeDistance == currentDistance) realDistance = currentDistance;</span><br><span class="line"></span><br><span class="line">        Vector3 finalPosition = target.position + direction.normalized * realDistance;</span><br><span class="line">        </span><br><span class="line">        transform.position = finalPosition;</span><br><span class="line">        transform.LookAt(target.position + Vector3.up * <span class="number">0.5f</span>); <span class="comment">// 看向角色头部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="角色移动脚本（相对于相机朝向的移动）"><a href="#角色移动脚本（相对于相机朝向的移动）" class="headerlink" title="角色移动脚本（相对于相机朝向的移动）"></a>角色移动脚本（相对于相机朝向的移动）</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleMoveController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;玩家速度设置&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> maxMoveSpeed = <span class="number">3.0f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> rotateSmoothSpeed = <span class="number">35f</span>;  <span class="comment">//角色转向速度(用于线性插值)</span></span><br><span class="line">    <span class="comment">//public float rotateTime = 0.3f;         //角色转向所需时间(固定转向时间的线性插值)</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;跟随的摄像头坐标&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Transform cameraTransform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> horizontal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> vertical = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody playRB;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playRB = GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 nowSpeed = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        horizontal = <span class="number">0</span>;</span><br><span class="line">        vertical = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Vector3 directionFront = cameraTransform.rotation * Vector3.forward;</span><br><span class="line">        Vector3 directionRight = cameraTransform.rotation * Vector3.right;</span><br><span class="line">        directionFront = <span class="keyword">new</span> Vector3(directionFront.x, <span class="number">0</span>, directionFront.z);</span><br><span class="line">        directionRight = <span class="keyword">new</span> Vector3(directionRight.x, <span class="number">0</span>, directionRight.z);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.W))</span><br><span class="line">        &#123;</span><br><span class="line">            nowSpeed += maxMoveSpeed * directionFront;</span><br><span class="line">            vertical += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.S))</span><br><span class="line">        &#123;</span><br><span class="line">            nowSpeed += -maxMoveSpeed * directionFront;</span><br><span class="line">            vertical -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            nowSpeed += -maxMoveSpeed * directionRight;</span><br><span class="line">            horizontal -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.D))</span><br><span class="line">        &#123;</span><br><span class="line">            nowSpeed += maxMoveSpeed * directionRight;</span><br><span class="line">            horizontal += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nowSpeed = nowSpeed.normalized;</span><br><span class="line">        nowSpeed *= maxMoveSpeed;</span><br><span class="line">        playRB.velocity = nowSpeed;</span><br><span class="line">        <span class="keyword">if</span>(playRB.velocity.magnitude &gt; <span class="number">1e-6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Quaternion targetRotation = Quaternion.LookRotation(playRB.velocity.normalized);</span><br><span class="line">            Quaternion smoothRotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * rotateSmoothSpeed);</span><br><span class="line">            playRB.MoveRotation(smoothRotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	上面是完整移动脚本。需要获取的基本数据，有部分数据可能没有使用到，是我测试代码时使用的数据。</p>
<p>​	该脚本与传统移动脚本不同的地方需要注意的是下面的这个相对摄像机朝向的前方和右方的方向向量的计算。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 directionFront = cameraTransform.rotation * Vector3.forward;</span><br><span class="line">     Vector3 directionRight = cameraTransform.rotation * Vector3.right;</span><br><span class="line">     directionFront = <span class="keyword">new</span> Vector3(directionFront.x, <span class="number">0</span>, directionFront.z);</span><br><span class="line">     directionRight = <span class="keyword">new</span> Vector3(directionRight.x, <span class="number">0</span>, directionRight.z)</span><br></pre></td></tr></table></figure>

<p>​	还有下面这一段关于角色面向移动方向的线性插值实现代码，这里实际上我有考虑过两种实现，一种是直接用朴素的旋转速度来控制线性插值，一种是固定一个旋转时间使得转向任意角度都是一个固定的时间。最后基于实现难度和实际效果，我认为直接使用朴素的旋转速度来控制线性插值即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(playRB.velocity.magnitude &gt; <span class="number">1e-6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Quaternion targetRotation = Quaternion.LookRotation(playRB.velocity.normalized);</span><br><span class="line">    Quaternion smoothRotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * rotateSmoothSpeed);</span><br><span class="line">    playRB.MoveRotation(smoothRotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="鼠标光标隐藏脚本"><a href="#鼠标光标隐藏脚本" class="headerlink" title="鼠标光标隐藏脚本"></a>鼠标光标隐藏脚本</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MouseController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> lockCursor = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HideMouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))</span><br><span class="line">        &#123;</span><br><span class="line">            ShowMouse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            HideMouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HideMouse</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Cursor.visible = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (lockCursor)</span><br><span class="line">        &#123;</span><br><span class="line">            Cursor.lockState = CursorLockMode.Locked;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowMouse</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Cursor.visible = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(lockCursor)</span><br><span class="line">        &#123;</span><br><span class="line">            Cursor.lockState = CursorLockMode.None;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	就是基础的对于unity Cursor类的使用，具体的函数及变量作用可以查询unity开发者api脚本手册。</p>
]]></content>
      <categories>
        <category>unity demo</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>3D</tag>
        <tag>C#</tag>
        <tag>Camera脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2163D2 D2. Diadrash (Hard Version)题解</title>
    <url>/2025/11/11/CF2163D2-D2-Diadrash-Hard-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D2-Diadrash-Hard-Version"><a href="#D2-Diadrash-Hard-Version" class="headerlink" title="D2. Diadrash (Hard Version)"></a><a href="https://codeforces.com/contest/2163/problem/D2">D2. Diadrash (Hard Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	这是一道交互题，题目中有一个隐藏的排列，我们得到了q组询问，每组询问[l, r]，我们需要求出所有询问中MEX[l, r]最大的是多少，我们可以进行提问 ? l r，交互其会返回区间[l, r]的MEX。我们需要在30次询问内找出答案。排列长度n &lt;&#x3D; 1e4, 询问q &lt;&#x3D; 3e5。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先本题根据MEX的性质，我们不难发现所有被完全包含的区间都没有意义，所以我们对区间进行区去包含的处理，此时最多只会剩下n个区间询问。我们要解决hard版的30次询问还需要注意到MEX的另外一个重要性质，对于MEX[l, r] &#x3D; min(MEX[1, r], MEX[l, n])，这个性质的证明考虑第一个不在MEX[l, r]中的数位于其左侧或右侧就可以简单证明得到。</p>
<p>​	我们对去重后的区间按左端点进行排序，我们可以对这些区间进行二分，因为去了包含之后的区间一定满足l[i] &lt; l[i + 1], r[i] &lt; r[i + 1]。对于我们当前验证的区间media，若其为[l, r],我们记a &#x3D; MEX[1, r], b &#x3D; MEX[l, n]，若a &lt; b，则我们只有考虑media区间右侧的区间即可，因为此时我们需要让r变大才有可能使得MEX[l, r]更大。若a &gt; b同理，所以我们可以二分缩小一半的可能（带来更大答案的区间只可能在一个半边），故解法成立，询问次数 2 * lg(n) &lt;&#x3D; 30。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; space &lt;&lt; r &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    std::cin &gt;&gt; ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> mid = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">lpos</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        std::cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        lpos[l] = std::<span class="built_in">max</span>(lpos[l], r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r_get = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lpos[i] &gt; r_get)&#123;</span><br><span class="line">            qu.<span class="built_in">push_back</span>(&#123;i, lpos[i]&#125;);</span><br><span class="line">            r_get = lpos[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = qu.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> media = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> l = qu[media].ff;</span><br><span class="line">        <span class="type">int</span> r = qu[media].ss;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">ask</span>(<span class="number">1</span>, r);</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">ask</span>(l, n);</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, std::<span class="built_in">min</span>(a, b));</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">            left = media + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right = media - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; space &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2500</tag>
        <tag>交互</tag>
        <tag>二分</tag>
        <tag>MEX</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1673F F. Anti-Theft Road Planning题解</title>
    <url>/2025/10/16/CF1673F-F-Anti-Theft-Road-Planning%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F-Anti-Theft-Road-Planning"><a href="#F-Anti-Theft-Road-Planning" class="headerlink" title="F. Anti-Theft Road Planning"></a><a href="https://codeforces.com/contest/1673/problem/F">F. Anti-Theft Road Planning</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个n * n的矩阵，矩阵中的每个格子都是四联通的，有个小偷初始位于（0，0）要在这个矩阵中偷盗，我们有报警器，小偷每次经过报警器的数值都会异或上小偷经过的路径的长度，报警器的初始数值为0。当小偷进行盗窃时报警器会告诉我们数值并且将报警器数值重置为0，我们需要根据这个数值输出小偷具体的坐标。我们需要构造每个格子之间的距离，输出构造方案并完成交互，格子距离的和不可以超过48000。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们意识到我们要根据报警器确定小偷经过任何路径走到[x, y]的坐标，意味着从[0, 0]走到[x, y]的所有路径的边权异或和都是相同的，我们可以给每个坐标赋一个边权异或和的值，然后根据这个值我们就可以反推出所有的路径长度。我们首先想到可以令值为0到n * n，但是构造之后我们发现此时的边权和到达了1e5的级别，超出了限制。</p>
<p>​	我们注意到两个坐标的权值之间我们应该让其具备尽可能多的相同的位，这样我们就可以最小化边权的和。如果是一维的坐标问题，那么显然格雷码就是答案，其保证了每个元素不同且相邻两个元素之间只有1个位不相同，并且保证了使更低位的不同次数更多。我们发现如果可以将格雷码拓展到二维那么我们就可以解决这个问题了，数据范围n &lt;&#x3D; 32,我们只要构造32即可。对于2 ^ k阶的二维格雷码我们类比一维各类码的拓展方式将二维各类码拓展出来，具体的对于[2  ^ k , 2 ^ k]的二维格雷码，我们先将其拓展成[2 ^ k,  2 ^ (k + 1)],在拓展成[2 ^ (k + 1), 2 ^ (k + 1)],对于同列和同行的拓展和一维格雷码相同，我们先赋值一遍翻转后放置原先的后面，并将新添加的码值的新的最高位全部赋值成1。</p>
<p>​	构造方案出来后我们维护小偷走过的边权异或和即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    val.<span class="built_in">assign</span>(<span class="number">2</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">auto</span> change = [&amp;]()&#123;</span><br><span class="line">        <span class="type">int</span> x = std::__lg((val.<span class="built_in">size</span>() - <span class="number">1</span>) * (val[<span class="number">1</span>].<span class="built_in">size</span>() - <span class="number">1</span>) - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; val.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = val[i].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">                val[i].<span class="built_in">push_back</span>(val[i][j]);</span><br><span class="line">                val[i].<span class="built_in">back</span>() |= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sz = val.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sz; i++)</span><br><span class="line">            val.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; val[<span class="number">1</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="type">int</span> str = sz + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = sz; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">                val[str].<span class="built_in">push_back</span>(val[i][j]);</span><br><span class="line">                val[str].<span class="built_in">back</span>() |= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">                str += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">while</span>(val.<span class="built_in">size</span>() &lt; N)&#123;</span><br><span class="line">        <span class="built_in">change</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            std::cout &lt;&lt; (val[i][j] ^ val[i][j + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j == n - <span class="number">1</span>)</span><br><span class="line">                std::cout &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; space;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            std::cout &lt;&lt; (val[i][j] ^ val[i + <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">if</span>(j == n)</span><br><span class="line">                std::cout &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                std::cout &lt;&lt; space;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        std::cin &gt;&gt; x;</span><br><span class="line">        now ^= x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(val[i][j] == now)&#123;</span><br><span class="line">                    std::cout &lt;&lt; i &lt;&lt; space &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>cf2400</tag>
        <tag>状态压缩</tag>
        <tag>交互</tag>
        <tag>格雷码</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF797F F. Mice and Holes题解</title>
    <url>/2025/09/27/CF797F-F-Mice-and-Holes%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F-Mice-and-Holes"><a href="#F-Mice-and-Holes" class="headerlink" title="F. Mice and Holes"></a><a href="https://codeforces.com/contest/797/problem/F">F. Mice and Holes</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们n只老鼠在一个水平线上的坐标，这个水平线上还有m个洞，我们需要让每个老鼠都会到一个洞中，每个洞都有一个水平线上的坐标和容量，我们需要输出让所有老鼠到达洞的最小总移动距离，如果不可能让所有老鼠都到洞中则输出-1。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先本题我们容易发现我们将洞和老鼠都排个序按坐标从小到大来考虑比较简单，我们容易得到一个O（n ^ 3)的dp解法，我们可以定义dp[i] [j] [k]表示考虑到第i支老鼠第j个洞，第j个洞进了k只老鼠的最小代价。根据贪心策略我们容易证明坐标小的老鼠进的洞一定小于等于坐标大的老鼠进的洞的坐标。但是O(n ^ 3)的时间复杂度我们无法接受。</p>
<p>​	并且这个状态设计并不好优化，考虑转换状态，定义dp[i] [j]表示考虑到第i个洞进入了j只老鼠的最小代价。这个dp[i] [j] &#x3D; Min(dp[i - 1] [j - k] + pre[i] [j] -  pre[i] [j - k]) ，pre[i] [j]表示前j只老鼠进入第i个洞的代价。容易发现这个dp的j - k可以拎出来进行优化，于是每个转移实际上是查询一个区间长度为k的区间的最小值，这可以使用单调队列来左到O(1)的查询。于是我们使用单调队列优化这个dp即可。</p>
<p>​	本题实际上还有O(n * lgn)的反悔贪心解法。具体的我们把洞和老鼠放到一起排序，当添加一个老鼠时我们会对其找最近的洞进行匹配，答案增加x - y。当洞进入时我们考虑对之前的老鼠进行反悔贪心，取消之前的贡献再加上新的贡献 -(x - y) + nowx - x，我们只要贪心的挑选y - 2 * x最大的即可。此外我们把这个贪心再次反悔，即让之后的老鼠进这个洞，我们撤销这次让之前老鼠进这个洞的贡献作为后续老鼠匹配这个洞的影响加入到维护洞的优先队列中。这样我们将老鼠的影响维护一个优先队列，将洞的影响维护一个优先队列，进行返回贪心就解决了本题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i];</span><br><span class="line">    std::<span class="built_in">sort</span>(cur.<span class="built_in">begin</span>() + <span class="number">1</span>, cur.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">pos</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; pos[i].ff &gt;&gt; pos[i].ss;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(pos.<span class="built_in">begin</span>() + <span class="number">1</span>, pos.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, std::vector&lt;ll&gt;(n + <span class="number">1</span>, <span class="number">1e18</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        std::deque&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> c = pos[i].ss;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="function">std::vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            pre[j] = pre[j - <span class="number">1</span>] + std::<span class="built_in">abs</span>(cur[j] - pos[i].ff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; dp[i - <span class="number">1</span>][stk.<span class="built_in">back</span>()] - pre[stk.<span class="built_in">back</span>()] &gt;= dp[i - <span class="number">1</span>][j] - pre[j])&#123;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(j);</span><br><span class="line">            <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">front</span>() &lt; j - c)&#123;</span><br><span class="line">                stk.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][stk.<span class="built_in">front</span>()] + pre[j] - pre[stk.<span class="built_in">front</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; (dp[m][n] &gt;= <span class="number">1e18</span> ? <span class="number">-1</span> : dp[m][n]) &lt;&lt; endl;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>cf2600</tag>
        <tag>单调队列</tag>
        <tag>反悔贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1859E E. Maximum Monogonosity题解</title>
    <url>/2025/09/21/CF1859E-E-Maximum-Monogonosity%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Maximum-Monogonosity"><a href="#E-Maximum-Monogonosity" class="headerlink" title="E. Maximum Monogonosity"></a><a href="https://codeforces.com/contest/1859/problem/E">E. Maximum Monogonosity</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们两个长度为n的数组a和数组b，我们需要从1到n中挑选一些区间[L1, R1], [L2, R2]…满足这些区间没有相交，同时直接区间的贡献最大，定义每个区间[l, r]的贡献是std::abs(a[l] - b[r]) + std::abs(b[l] - a[r])。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们容易思考到一个O（n * k * k)的暴力dp，我们可以定义dp[i] [j]表示考虑了前i个数，线段总长度为j的最大贡献，转移时O（k）的向前枚举即可。但这样的时间复杂度无法接受，考虑是否能够优化这个dp，绝对值不是很好处理，我们可以先把绝对值拆开，实际上只有a[l] - b[r] + b[l] - a[r], b[r] - a[l] + b[l] - a[r], a[l] - b[r] + a[r] - b[l], b[r] - a[l] + a[r] - b[l]，这四种方式的转移，因为绝对值的性质，我们取其中最大的转移方式即可。</p>
<p>​	注意到此时我们暴力dp的状态转移方程从dp[i] [j] &#x3D; dp[i - k] [j - k] + std::abs(a[i - k + 1] - b[i]) + std::abs(b[i - k + 1] - a[i])变成了没有绝对值的形式，我们把dp[i - k] [j - k] 与 a[i - k + 1] 和 b[i - k + 1]联立在一起，发现这个转移实际上是一个前缀最大值，我们可以使用前缀和进行优化dp。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; b[i];</span><br><span class="line">    <span class="function">std::vector <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;ll&gt;(k + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">std::vector <span class="title">f</span><span class="params">(n + <span class="number">1</span>, std::vector&lt;ll&gt;(<span class="number">4</span>, <span class="number">-1e18</span>))</span></span>;</span><br><span class="line">    <span class="comment">//a[l] - b[r] + b[l] - a[r]</span></span><br><span class="line">    <span class="comment">//-a[l] + b[r] - b[l] + a[r]</span></span><br><span class="line">    <span class="comment">//-a[l] + b[r] + b[l] - a[r]</span></span><br><span class="line">    <span class="comment">//a[l] - b[r] - b[l] + a[r]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= std::<span class="built_in">min</span>(k, i); j++)&#123;</span><br><span class="line">            f[i - j][<span class="number">0</span>] = std::<span class="built_in">max</span>(f[i - j][<span class="number">0</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i] + b[i]);</span><br><span class="line">            f[i - j][<span class="number">1</span>] = std::<span class="built_in">max</span>(f[i - j][<span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - a[i] - b[i]);</span><br><span class="line">            f[i - j][<span class="number">2</span>] = std::<span class="built_in">max</span>(f[i - j][<span class="number">2</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - a[i] + b[i]);</span><br><span class="line">            f[i - j][<span class="number">3</span>] = std::<span class="built_in">max</span>(f[i - j][<span class="number">3</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i] - b[i]);</span><br><span class="line"></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i][j] = std::<span class="built_in">max</span>(dp[i][j], f[i - j][<span class="number">0</span>] - a[i] - b[i]);</span><br><span class="line">            dp[i][j] = std::<span class="built_in">max</span>(dp[i][j], f[i - j][<span class="number">1</span>] + a[i] + b[i]);</span><br><span class="line">            dp[i][j] = std::<span class="built_in">max</span>(dp[i][j], f[i - j][<span class="number">2</span>] - a[i] + b[i]);</span><br><span class="line">            dp[i][j] = std::<span class="built_in">max</span>(dp[i][j], f[i - j][<span class="number">3</span>] + a[i] - b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; dp[n][k] &lt;&lt; endl;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>cf2500</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1794E E. Labeling the Tree with Distances题解</title>
    <url>/2025/09/17/CF1794E-E-Labeling-the-Tree-with-Distances%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Labeling-the-Tree-with-Distances"><a href="#E-Labeling-the-Tree-with-Distances" class="headerlink" title="E. Labeling the Tree with Distances"></a><a href="https://codeforces.com/contest/1794/problem/E">E. Labeling the Tree with Distances</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个n个节点的树，还有n - 1个标签，我们还可以自由挑选一个任意数值的标签，当以某个节点为根时，树中每个节点的到根节点的距离能与n个标签一一对应，那么我们就称这个作为根节点的点为好点。我们需要求出所有的好点并按照升序输出。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们可以想到对于某个节点为根的树维护所有节点到他的距离可以考虑换根dp，但是此时我们还是无法很好的考虑距离为x的节点的数量，并且我们无法快速的对n个标签，其中还有一个不确定的标签进行快速判断是否符合要求。</p>
<p>​	我们重新思考我们的需求，我们需要判断一个数组每个元素的值的出现次数是否相同，我们发现这类似于字符串的一个个判断，考虑对这个数组进行类似进制哈希的做法，列入cnt0 * base0 + cnt1 * base1 + cnt2 * base2，这样的进制哈希我们也是可以换根dp来维护某个节点为根时所有到它距离的距离cnt的哈希数值的。同时我们注意到对于未确定的那个标签实际上只有n种可能，因为树的深度不超过n，所以我们可以每个都尝试一下，处理出哈希放到set里即可帮助我们快速判断。这实际上是一个线段树优化哈希，注意到本题的哈希值种类有1e5种，对哈希的强度有一定需求，可以使用多模值哈希或是直接放大哈希的值域范围，我代码里的做法手写了int128的乘法来将哈希的值域放大到了1e18，这样哈希冲突的概率极低，模数使用1e18 + 9，base使用随机生成的大进位数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll mod = ((ll)<span class="number">1e18</span>) + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __int128(a) * b % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    ll base = <span class="built_in">rng</span>() % <span class="number">1000000000</span> + <span class="number">234567</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        p[i] = <span class="built_in">mul</span>(p[i - <span class="number">1</span>], base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        std::cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= n)</span><br><span class="line">            cnt[x] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        vec[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        vec[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; x &lt;&lt; space &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        now = <span class="built_in">mul</span>(now, base);</span><br><span class="line">        now += cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::set&lt;ll&gt; win;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        ll res = p[i];</span><br><span class="line">        win.<span class="built_in">insert</span>((res + now) % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">hash</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs1 = [&amp;](<span class="type">int</span> node, <span class="type">int</span> fa, <span class="type">int</span> dep)&#123;</span><br><span class="line">        hash[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : vec[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(v, node, dep + <span class="number">1</span>);</span><br><span class="line">                hash[node] = (<span class="built_in">mul</span>(hash[v], base) + hash[node]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, ll)&gt; dfs2 = [&amp;](<span class="type">int</span> node, <span class="type">int</span> fa, ll hashnow) -&gt; <span class="type">void</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(win.<span class="built_in">count</span>(hashnow))&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : vec[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">                ll hashto = (hashnow - <span class="built_in">mul</span>(hash[v], base)) % mod;</span><br><span class="line">                hashto = (hashto + mod) % mod;</span><br><span class="line">                hashto = <span class="built_in">mul</span>(hashto, base);</span><br><span class="line">                hashto = (hashto + hash[v]) % mod;</span><br><span class="line">                <span class="built_in">dfs2</span>(v, node, hashto);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">-1</span>, hash[<span class="number">1</span>]);</span><br><span class="line">    std::cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    std::<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; ans[i] &lt;&lt; sendl[i == ans.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>哈希</tag>
        <tag>cf2400</tag>
        <tag>动态规划</tag>
        <tag>换根dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2075E E. XOR Matrix题解</title>
    <url>/2025/09/15/CF2075E-E-XOR-Matrix%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-XOR-Matrix"><a href="#E-XOR-Matrix" class="headerlink" title="E. XOR Matrix"></a><a href="https://codeforces.com/contest/2075/problem/E">E. XOR Matrix</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们n，m，A，B。我们需要确认有多少种不同的数组(a, b)对是好的，a，b均是数组，a中的元素在0到A之间，b中的元素在0到B之间。数组中a中的任意元素异或上b中的任意元素得到的结果最多只能有2种。输出多少种，在模998244353的意义下。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们发现可以分开来考虑相同结果为1种和相同结果为2种的情况，对于结果只有一种的数，一定是数组a中为i，数组b中为j，共两种不同的数。对于相同的结果为2的情况一定是数组a为i，数组b为j，k，或者反过来。结果为2还有可能是（i，j）for a， （k， l） for b，此时还要满足i ^ j ^ k ^ l &#x3D;&#x3D; 0,我们发现只有最后一种情况我们比较难以完成计数，其余的情况我们都可以通过组合数学的公式快速推到出来。</p>
<p>​	考虑如何计算四个数字i，j，k，l满足异或和为0，且i !&#x3D; j 并且k !&#x3D; l,同时i，j属于[0, A] ，k，l属于[0, B]。我们发现我们可以拆成一位一位的看，每位中为1的位的个数一定要是偶数，这样的话我们可以使用类似数位dp的方式来完成计数，标记每个数字是否处于上限和i是否等于j，k是否等于l即可。注意我们dp出来的结果在后面考虑实际插入时会偏大，我们考虑插入的实际意义实际上是真实的4倍，需要除以4（例如（10，10）（01，10）（10，01）（01，01）,  会被我们每种01，10考虑到）。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll k, ll m)</span></span>&#123;   <span class="comment">//求a^k mod m</span></span><br><span class="line">    a %= m;</span><br><span class="line">    ll res = <span class="number">1</span> % m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * a % m;<span class="comment">//指数k为1的位乘上a^(1&lt;&lt;x)mod m</span></span><br><span class="line">        a = a * a % m;<span class="comment">//每一项是前一项的平方模m</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n, m, A, B;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="comment">//std::cerr &lt;&lt; n &lt;&lt; space &lt;&lt; m &lt;&lt; space &lt;&lt; A &lt;&lt; space &lt;&lt; B &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    ll dp[<span class="number">31</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    std::function&lt;ll(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> pos, <span class="type">int</span> limit1, <span class="type">int</span> limit2, <span class="type">int</span> same1, <span class="type">int</span> limit3, <span class="type">int</span> limit4, <span class="type">int</span> same2) -&gt; ll&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">return</span> ((!same1) &amp;&amp; (!same2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; pos &lt;&lt; space &lt;&lt; limit1 &lt;&lt; limit2 &lt;&lt; limit3 &lt;&lt; limit4 </span></span><br><span class="line">        <span class="keyword">if</span>(dp[pos][limit1][limit2][same1][limit3][limit4][same2] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[pos][limit1][limit2][same1][limit3][limit4][same2];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">1</span>; l++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>((i + j + k + l) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="type">int</span> up1 = (A &gt;&gt; pos) &amp; <span class="number">1</span>;</span><br><span class="line">                            <span class="type">int</span> up2 = (B &gt;&gt; pos) &amp; <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span>(i &gt; up1 &amp;&amp; limit1)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span>(j &gt; up1 &amp;&amp; limit2)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span>(k &gt; up2 &amp;&amp; limit3)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span>(l &gt; up2 &amp;&amp; limit4)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                            </span><br><span class="line">                            ans = (ans + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limit1 &amp;&amp; (i == up1), limit2 &amp;&amp; (j == up1), (i == j) &amp; same1,</span><br><span class="line">                            limit3 &amp;&amp; k == up2, limit4 &amp;&amp; l == up2, (k == l) &amp; same2)) % mod;</span><br><span class="line">                            <span class="comment">//std::cerr &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; pos &lt;&lt; space &lt;&lt; limit1 &lt;&lt; limit2 &lt;&lt; limit3 &lt;&lt; limit4 &lt;&lt; space &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> dp[pos][limit1][limit2][same1][limit3][limit4][same2] = ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    ll res = <span class="built_in">dfs</span>(<span class="number">30</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    res = res * <span class="built_in">qmi</span>(<span class="number">4</span>, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ans = (res *(<span class="built_in">qmi</span>(<span class="number">2</span>, n, mod) - <span class="number">2</span>) % mod * (<span class="built_in">qmi</span>(<span class="number">2</span>, m, mod) - <span class="number">2</span>) % mod + ans) % mod;</span><br><span class="line"></span><br><span class="line">    ans = (ans + (A + <span class="number">1</span>) * (B + <span class="number">1</span>) % mod) % mod;</span><br><span class="line"></span><br><span class="line">    ans = (ans + (A + <span class="number">1</span>) * (B + <span class="number">1</span>) % mod * B % mod * (<span class="built_in">qmi</span>(<span class="number">2</span>, m, mod) - <span class="number">2</span>) % mod * <span class="built_in">qmi</span>(<span class="number">2</span>, mod - <span class="number">2</span>, mod) % mod) % mod;</span><br><span class="line">    ans = (ans + (B + <span class="number">1</span>) * (A + <span class="number">1</span>) % mod * A % mod * (<span class="built_in">qmi</span>(<span class="number">2</span>, n, mod) - <span class="number">2</span>) % mod * <span class="built_in">qmi</span>(<span class="number">2</span>, mod - <span class="number">2</span>, mod) % mod) % mod;</span><br><span class="line"></span><br><span class="line">    ans = (ans + mod) % mod;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
        <tag>cf2500</tag>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2121G G. Gangsta题解</title>
    <url>/2025/09/10/CF2121G-G-Gangsta%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="G-Gangsta"><a href="#G-Gangsta" class="headerlink" title="G. Gangsta"></a><a href="https://codeforces.com/contest/2121/problem/G">G. Gangsta</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的二进制字符串s，我们要计算s所有子数组中函数f值，f（s）的值是二进制字符串中最多的相同字符的个数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	我们考虑如何暴力的做这道题目，定义状态dp[i][j]表示以i为结尾1的个数减去0的个数等于j的子段的数量，ans[i]表示以i为结尾的所有子段做的贡献。我们考虑拓展到i + 1,首先ans[i]的贡献在i + 1时一定会产生，然后考虑新增的贡献，假设此时s[i] &#x3D;&#x3D; ‘1’，那么原先dp[i][j]中j &gt;&#x3D; 0的都会新增贡献，s[i] &#x3D;&#x3D; ‘0’时也是同理。但是这个dp暴力维护的时间复杂度是O（n ^ 2)的。</p>
<p>​	考虑如何优雅的维护，我们发现遇到1时，实际上原先1的个数减去0的个数为-1的子段变成了为0的子段，我们可以标记一个offset来表示实际上此时为子段中1的个数减去0的个数的位置，我们注意到每次offset只会变动1个位置，我们可以O（1)的维护出大于它的（也就是上面dp中j &gt;&#x3D; 0）的个数，可以快速算出此时新增的贡献,注意别忘了还要加上ans[i]的贡献（也就是右端点位于上一个位置的贡献）。遇到0时也是同理。实际上这个维护思路我觉得有点类似长链刨分优化dp。时间复杂度O(n)</p>
<p>​	举个例子，对于10011，初始offset为0，考虑第一个元素1，此时count数组中count[0] +&#x3D; 1,offset -&#x3D; 1,此时offset为-1，所有count[j] (j &gt; -1)都会做贡献，此时新增贡献1。考虑第二个元素0，此时count[-1] +&#x3D; 1, offset +&#x3D; 1,，此时offset为0，所有count[j] (j &lt; 0)都会做新增贡献，此时新增贡献1，注意此时右端点在位置2的总贡献还要加上右端点为1位置的1，实际总贡献为2。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot;@&quot;</span> + s;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">2</span> * n + <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    ll smal = <span class="number">0</span>;</span><br><span class="line">    ll big = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> offset = n;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            count[offset] += <span class="number">1</span>;</span><br><span class="line">            smal += count[offset];</span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">            big -= count[offset];</span><br><span class="line">            res += smal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            count[offset] += <span class="number">1</span>;</span><br><span class="line">            big += count[offset];</span><br><span class="line">            offset -= <span class="number">1</span>;</span><br><span class="line">            smal -= count[offset];</span><br><span class="line">            res += big;</span><br><span class="line">        &#125;</span><br><span class="line">        ll now = last + res;</span><br><span class="line">        ans += now;</span><br><span class="line">        last = now;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>动态规划</tag>
        <tag>组合数学</tag>
        <tag>cf1900</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1945G G. Cook and Porridge题解</title>
    <url>/2025/09/06/CF1945G-G-Cook-and-Porridge%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="G-Cook-and-Porridge"><a href="#G-Cook-and-Porridge" class="headerlink" title="G. Cook and Porridge"></a><a href="https://codeforces.com/contest/1945/problem/G">G. Cook and Porridge</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们n个排着队的学生，每个学生都有一个优先级和吃饭时间，初始时按照1到n排序，每一秒在最前面的学生可以得到吃的，然后他会花费s[i]的吃饭时间吃饭，记录当前时间为x，则他会在x + s[i]的时刻结束时回来排队，此时对尾所有优先即严格低于他的学生都会被他插队，直到遇到优先级大于等于他的。我们需要计算1到d秒内所有学生都吃过一回饭的最小时刻，或者报告不可能。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	注意到d的数据范围很小，同时每个时刻只有一个学生会吃饭，所以归队的学生也最多d个，考虑模拟这个过程。我们发现因为初始状态的优先级不是单调的我们很难处理，但是我们可以注意到每次插入后当前元素所在的那个小块一定是优先级别大到小的递减的。所以我们考虑维护初始状态的后缀最大值，我们每次学生归队时通过二分找出他会被拦截在哪个块的后面，然后在这个块的后面插入，此时每个块中的元素都是优先级单调的，我们可以直接使用set维护即可，每一块中优先级大的靠钱，相同则比较插入时间，插入时间小的考前。我们在开一个set维护哪几个块中有元素即可取出队首的元素。记录每个学生是否吃过饭，全吃过记录答案退出即可。</p>
<p>​	另外一种比较简单的实现方式是直接使用平衡树，注意到如果初始队列的优先级别是单调的我们直接使用一个优先队列即可维护。我们发现插入的规则是固定的，但初始的元素可能不满足这个规则，我们可以直接用平衡树手动初始化节点，最后按照规则插入即可。具体的可以维护每个子树内节点的优先级最大值，队首就是最左侧存活的节点。我的代码使用的替罪羊树进行实现。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set维护</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> ci;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">k</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; k[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">suf</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        suf[i] = std::<span class="built_in">max</span>(suf[i + <span class="number">1</span>], k[i]);</span><br><span class="line">        res.<span class="built_in">push_back</span>(suf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k[a.ff] != k[b.ff])</span><br><span class="line">            <span class="keyword">return</span> k[a.ff] &gt; k[b.ff];</span><br><span class="line">        <span class="keyword">return</span> a.ss &lt; b.ss;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt;&gt; <span class="built_in">pos</span>(n + <span class="number">1</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="keyword">decltype</span>(cmp)&gt;(cmp));</span><br><span class="line">    <span class="comment">//[id, cha]</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; se;   <span class="comment">//pos who has num</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        pos[i].<span class="built_in">insert</span>(&#123;i, i&#125;);</span><br><span class="line">        se.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cha = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">time</span>(d + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; i++)&#123;</span><br><span class="line">        <span class="type">int</span> who = *se.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> p = *pos[who].<span class="built_in">begin</span>();</span><br><span class="line">        pos[who].<span class="built_in">erase</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(pos[who].<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            se.<span class="built_in">erase</span>(who);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!vis[p.ff])&#123;</span><br><span class="line">            vis[p.ff] = <span class="literal">true</span>;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + s[p.ff] &lt;= d)&#123;</span><br><span class="line">            time[i + s[p.ff]].<span class="built_in">push_back</span>(p.ff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(time[i].<span class="built_in">begin</span>(), time[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[a] &lt; s[b];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : time[i])&#123;</span><br><span class="line">            <span class="type">int</span> now = k[x];</span><br><span class="line">            <span class="type">int</span> ind = std::<span class="built_in">lower_bound</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), now) - res.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">int</span> qu = n - ind;</span><br><span class="line">            pos[qu].<span class="built_in">insert</span>(&#123;x, cha&#125;);</span><br><span class="line">            <span class="keyword">if</span>(pos[qu].<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">                se.<span class="built_in">insert</span>(qu);</span><br><span class="line">            &#125;</span><br><span class="line">            cha += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt == n)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; (ans == <span class="number">0</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平衡树维护</span></span><br><span class="line"><span class="comment">//该平衡树的模板根据题意重构了，部分注释可能不对，为模板原来的注释</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scapegoat</span>&#123;</span><br><span class="line">    <span class="comment">//该模板的BST，左侧子节点的值小于等于当前节点的值</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> alpha = <span class="number">0.75</span>;    <span class="comment">//替罪羊树的不平衡度，通常在0.7左右</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> ls, rs;</span><br><span class="line">        T val;</span><br><span class="line">        T id;</span><br><span class="line">        T maxn;</span><br><span class="line">        <span class="type">int</span> tot;    <span class="comment">//实际存储的空间，包括删除的节点</span></span><br><span class="line">        <span class="type">int</span> size;   <span class="comment">//实际存储的节点，不包括删除的节点</span></span><br><span class="line">        <span class="type">int</span> save;   <span class="comment">//该节点是否存活，1存活，0删除</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Node&gt; tree;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; order; <span class="comment">//用来记录中序遍历的结果</span></span><br><span class="line">    <span class="type">int</span> cnt;    <span class="comment">//使用数组模拟，vector当数组用减小常数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tree_stack;    <span class="comment">//记录可用空间的栈</span></span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">//tree_stack 的栈顶</span></span><br><span class="line">    <span class="type">int</span> root;   <span class="comment">//当前的根节点，替罪羊树中根节点会变动</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;    <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!u)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">Inorder</span>(tree[u].ls);</span><br><span class="line">        <span class="keyword">if</span>(tree[u].save)</span><br><span class="line">            order[++cnt] = u;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree_stack[++top] = u;</span><br><span class="line">        <span class="built_in">Inorder</span>(tree[u].rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Initnode</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        tree[u].ls = tree[u].rs = <span class="number">0</span>;</span><br><span class="line">        tree[u].size = tree[u].tot = tree[u].save = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        tree[u].size = tree[tree[u].ls].size + tree[tree[u].rs].size + tree[u].save;   <span class="comment">//注意这里是1，需要保证u存活</span></span><br><span class="line">        tree[u].tot = tree[tree[u].ls].tot + tree[tree[u].rs].tot + <span class="number">1</span>;</span><br><span class="line">        tree[u].maxn = std::<span class="built_in">max</span>(&#123;tree[u].val, tree[tree[u].ls].maxn, tree[tree[u].rs].maxn&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; u)</span></span>&#123;   <span class="comment">//注意这里的u是引用</span></span><br><span class="line">        rebuild_num++;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        u = order[mid];</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="built_in">Initnode</span>(u);</span><br><span class="line">            tree[u].maxn = tree[u].val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; mid)</span><br><span class="line">            <span class="built_in">build</span>(l, mid - <span class="number">1</span>, tree[u].ls);</span><br><span class="line">        <span class="keyword">if</span>(l == mid)</span><br><span class="line">            tree[u].ls = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">build</span>(mid + <span class="number">1</span>, r, tree[u].rs);</span><br><span class="line">        <span class="built_in">Update</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span>&amp; u)</span></span>&#123;   <span class="comment">//重建函数，调用中序遍历的结果进行构建</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">Inorder</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(cnt)</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">1</span>, cnt, u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">notbalance</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若一颗子树的占比超过了平衡率则不平衡</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="type">double</span>) tree[u].size * alpha &lt;= (<span class="type">double</span>) std::<span class="built_in">max</span>(tree[tree[u].ls].size, tree[tree[u].rs].size))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> rebuild_num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*测试使用</span></span><br><span class="line"><span class="comment">    int deep_timer = 0;</span></span><br><span class="line"><span class="comment">    int max_deep = 0;</span></span><br><span class="line"><span class="comment">    std::vector&lt;int&gt; tree_deep;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    void cnt_deep(int u)&#123;</span></span><br><span class="line"><span class="comment">        if(u)&#123;</span></span><br><span class="line"><span class="comment">            tree_deep[u] = ++deep_timer;</span></span><br><span class="line"><span class="comment">            max_deep = std::max(max_deep, tree_deep[u]);</span></span><br><span class="line"><span class="comment">            cnt_deep(tree[u].ls);</span></span><br><span class="line"><span class="comment">            cnt_deep(tree[u].rs);</span></span><br><span class="line"><span class="comment">            deep_timer--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u)&#123;</span><br><span class="line"></span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;id = &quot;</span> &lt;&lt; tree[u].id &lt;&lt; <span class="string">&quot;,l = &quot;</span> &lt;&lt; tree[tree[u].ls].id &lt;&lt; <span class="string">&quot;,r = &quot;</span> &lt;&lt; tree[tree[u].rs].id &lt;&lt; endl;</span><br><span class="line">            std::cerr &lt;&lt; tree[tree[u].rs].maxn &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print_tree</span>(tree[u].ls);</span><br><span class="line">            <span class="comment">// if(tree[u].save)</span></span><br><span class="line">            <span class="comment">//     std::cerr &lt;&lt; tree[u].id &lt;&lt; space;</span></span><br><span class="line">            <span class="built_in">print_tree</span>(tree[u].rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;     <span class="comment">//获取第k小的数的值</span></span><br><span class="line">        <span class="type">int</span> u = root;</span><br><span class="line">        <span class="keyword">while</span>(u)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[u].save &amp;&amp; tree[tree[u].ls].size + <span class="number">1</span> == k)</span><br><span class="line">                <span class="keyword">return</span> tree[u].id;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tree[tree[u].ls].size &gt;= k)</span><br><span class="line">                u = tree[u].ls;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                k -= tree[tree[u].ls].size + tree[u].save;</span><br><span class="line">                u = tree[u].rs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree[u].id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span>&amp; u, T x, T id)</span></span>&#123;     <span class="comment">//插入数字x</span></span><br><span class="line">        <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">            u = tree_stack[top--];</span><br><span class="line">            tree[u].val = x;</span><br><span class="line">            tree[u].id = id;</span><br><span class="line">            tree[u].maxn = x;</span><br><span class="line">            <span class="built_in">Initnode</span>(u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tree[u].size++;</span></span><br><span class="line">        <span class="comment">// tree[u].tot++;</span></span><br><span class="line">        <span class="keyword">if</span>(tree[tree[u].rs].size &amp;&amp; tree[tree[u].rs].maxn &gt;= x)</span><br><span class="line">            <span class="built_in">Insert</span>(tree[u].rs, x, id);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[u].save &amp;&amp; tree[u].val &gt;= x)</span><br><span class="line">            <span class="built_in">Insert</span>(tree[u].rs, x, id);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">Insert</span>(tree[u].ls, x, id);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Update</span>(u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">notbalance</span>(u))</span><br><span class="line">            <span class="built_in">rebuild</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(T x, T id)</span></span>&#123;</span><br><span class="line">        <span class="built_in">Insert</span>(root, x, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Del_k</span><span class="params">(<span class="type">int</span>&amp; u, <span class="type">int</span> k)</span></span>&#123;      <span class="comment">//删除第k大的数(直接使用不会触发重构，会有问题，需要手动控制重构)</span></span><br><span class="line">        <span class="comment">//tree[u].size--;</span></span><br><span class="line">        <span class="keyword">if</span>(tree[u].save &amp;&amp; tree[tree[u].ls].size + <span class="number">1</span> == k)&#123;</span><br><span class="line">            tree[u].save = <span class="number">0</span>;</span><br><span class="line">            tree[u].val = <span class="number">0</span>;</span><br><span class="line">            tree[u].maxn = <span class="number">0</span>;</span><br><span class="line">            tree[u].id = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">Update</span>(u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[tree[u].ls].size + tree[u].save &gt;= k)</span><br><span class="line">            <span class="built_in">Del_k</span>(tree[u].ls, k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">Del_k</span>(tree[u].rs, k - tree[tree[u].ls].size - tree[u].save);</span><br><span class="line">        <span class="built_in">Update</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Del</span><span class="params">()</span></span>&#123; <span class="comment">//删除第一个值</span></span><br><span class="line">        <span class="built_in">Del_k</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(tree[root].tot * alpha &gt;= tree[root].size)</span><br><span class="line">            <span class="built_in">rebuild</span>(root);      <span class="comment">//若删除的节点过多则重构</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Scapegoat</span>(<span class="type">int</span> n, std::vector&lt;<span class="type">int</span>&gt; k)&#123;</span><br><span class="line">        tree.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">Node</span>());</span><br><span class="line">        order.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        tree_stack.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        root = cnt = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            tree_stack[++top] = i;</span><br><span class="line"></span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&amp;)&gt; init = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>&amp; u)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!u)&#123;</span><br><span class="line">                u = tree_stack[top--];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//std::cerr &lt;&lt; u &lt;&lt; space &lt;&lt; mid &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">                tree[u].val = k[mid];</span><br><span class="line">                tree[u].id = mid;</span><br><span class="line">                tree[u].maxn = k[mid];</span><br><span class="line">                <span class="built_in">Initnode</span>(u);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l &lt; mid)</span><br><span class="line">                <span class="built_in">init</span>(l, mid - <span class="number">1</span>, tree[u].ls);</span><br><span class="line">            <span class="keyword">if</span>(l == mid)</span><br><span class="line">                tree[u].ls = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">init</span>(mid + <span class="number">1</span>, r, tree[u].rs);</span><br><span class="line">            <span class="built_in">Update</span>(u);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">init</span>(<span class="number">1</span>, k.<span class="built_in">size</span>() - <span class="number">1</span>, root);</span><br><span class="line">        <span class="comment">//tree_deep.resize(n + 1, 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Scapegoat</span>(<span class="type">int</span> n, <span class="type">double</span> new_alpha)&#123;</span><br><span class="line">        alpha = new_alpha;</span><br><span class="line">        tree.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">Node</span>());</span><br><span class="line">        order.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        tree_stack.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        root = cnt = top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            tree_stack[++top] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//tree_deep.resize(n + 1, 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">k</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; k[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scp = <span class="built_in">Scapegoat</span>&lt;<span class="type">int</span>&gt;((n + d) + <span class="number">10</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//scp.print_tree(scp.Root());</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">time</span>(d + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ind = scp.<span class="built_in">kth</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; &quot;time &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//scp.print_tree(scp.Root());</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(ind != <span class="number">0</span>);</span><br><span class="line">        scp.<span class="built_in">Del</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[ind])&#123;</span><br><span class="line">            vis[ind] = <span class="literal">true</span>;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + s[ind] &lt;= d)&#123;</span><br><span class="line">            time[i + s[ind]].<span class="built_in">push_back</span>(ind);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">sort</span>(time[i].<span class="built_in">begin</span>(), time[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[a] &lt; s[b];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : time[i])&#123;</span><br><span class="line">            scp.<span class="built_in">Insert</span>(k[x], x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt == n)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; (ans == <span class="number">0</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>模拟实现</tag>
        <tag>cf2500</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1858E2 E2. Rollbacks (Hard Version)题解</title>
    <url>/2025/09/01/CF1858E2-E2-Rollbacks-Hard-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E2-Rollbacks-Hard-Version"><a href="#E2-Rollbacks-Hard-Version" class="headerlink" title="E2. Rollbacks (Hard Version)"></a><a href="https://codeforces.com/contest/1858/problem/E2">E2. Rollbacks (Hard Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	初始有一个空的数组，我们需要对它进行q次操作，我们可以执行4种操作，操作+，添加一个元素x到数组后面。操作-，移除数组末尾的k个数字，操作！，撤回上一个操作，只会撤回+，-。操作？，输出数组种不同种类的数的个数。保证操作合法，hard版本要求强制在线。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先本题我们看见其回退操作自然考虑使用可持久化的数据结构进行维护，考虑可持久化线段树，发现我们可以维护一个权值线段树表示每个值得元素是否有贡献，添加操作实际上就是新版本新建一个单点处理，减去操作实际上就是创建一个当前版本的k级祖先的镜像版本，回退操作实际上就是直接删去一个版本即可。考虑如何快速回调k级版本的祖先，我们可以维护倍增，记录每个版本的父亲版本倍增状态。但这样写完之后我们发现会MLE，经过计算我们发现我们最多只有1.4e7的空间给可持久化线段树，这是不够的，考虑优化，我们只用标记某个值是否做了贡献，所以我们可以进行状态压缩，把所有长度为32的区间压缩到一个int里，这样我们线段树的值域范围可以&#x2F;32，这样我们需要1.6e7的空间。我们发现还是不够，考虑从倍增上搞点空间出来，以时间换空间倍增数组只用维护到2  ^ 17即可，这样我们就可以多出2e6的空间，就可以通过本题。</p>
<p>​	本题还有O（q）的解法，我们发现我们实际上可以维护当前数组的长度，每个数我们记录其最早出现的位置来做贡献，这样我们查询答案实际上相当于查询长度为len的前缀，我们可以同时维护长度为len的答案ans[len]即可，加的操作我们修改之前这个位置的数，删去贡献处理新加的数覆盖即可。减操作直接len -&#x3D; k即可。这样我们就解决了没有回退操作的解法，考虑如何处理回退操作，我们可以用栈维护每个操作带来的影响，最后直接弹出栈里的操作恢复状态即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(qlgq) 可持久化线段树</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//记录可以使用的新节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> ls;</span><br><span class="line">    <span class="type">int</span> rs;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> root[<span class="number">1000001</span>];</span><br><span class="line">node tree[<span class="number">16500001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">1000001</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> depth[<span class="number">1000001</span>];</span><br><span class="line"><span class="comment">//要开的空间数为n * lg(4 * n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//构建一颗只有lgn个新节点的新线段树</span></span><br><span class="line">    <span class="type">int</span> rt = ++cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cerr &lt;&lt; pl &lt;&lt; space &lt;&lt; pr &lt;&lt; space &lt;&lt; cnt &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">        <span class="type">int</span> now = x % <span class="number">32</span>;</span><br><span class="line">        tree[rt].val = tree[pre].val;</span><br><span class="line">        now = (now - <span class="number">1</span> + <span class="number">32</span>) % <span class="number">32</span>;</span><br><span class="line">        tree[rt].val |= (<span class="number">1</span> &lt;&lt; now);</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将该节点的左右儿子初始化为和上一颗线段树一样</span></span><br><span class="line">    tree[rt].ls = tree[pre].ls;</span><br><span class="line">    tree[rt].rs = tree[pre].rs;</span><br><span class="line">    <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pl &lt; pr)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x + <span class="number">32</span> - <span class="number">1</span>) / <span class="number">32</span> &lt;= mid)</span><br><span class="line">            tree[rt].ls = <span class="built_in">update</span>(tree[pre].ls, pl, mid, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tree[rt].rs = <span class="built_in">update</span>(tree[pre].rs, mid + <span class="number">1</span>, pr, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tree[rt].val = (pl == mid ? __builtin_popcount(tree[tree[rt].ls].val) : tree[tree[rt].ls].val)</span><br><span class="line">         + (pr == mid + <span class="number">1</span> ? __builtin_popcount(tree[tree[rt].rs].val) : tree[tree[rt].rs].val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">        <span class="type">int</span> now = x % <span class="number">32</span>;</span><br><span class="line">        now = (now - <span class="number">1</span> + <span class="number">32</span>) % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> ((tree[p].val &gt;&gt; now) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((x + <span class="number">32</span> - <span class="number">1</span>) / <span class="number">32</span> &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[p].ls, pl, mid, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[p].rs, mid + <span class="number">1</span>, pr, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1e6</span>;</span><br><span class="line">    <span class="type">int</span> maxn = (<span class="number">1e6</span> + <span class="number">32</span> - <span class="number">1</span>) / <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> getk = [&amp;](<span class="type">int</span> x, <span class="type">int</span> k)&#123;</span><br><span class="line">        k = std::<span class="built_in">min</span>(depth[x], k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">14</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= (<span class="number">1</span> &lt;&lt; i))&#123;</span><br><span class="line">                k -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                x = fa[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> father;</span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line"></span><br><span class="line">        std::cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            root[top] = <span class="built_in">update</span>(root[top - <span class="number">1</span>], <span class="number">1</span>, maxn, val);</span><br><span class="line">            father = top - <span class="number">1</span>;</span><br><span class="line">            node = top;</span><br><span class="line">            fa[node][<span class="number">0</span>] = father;</span><br><span class="line">            depth[node] = depth[father] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= <span class="number">14</span>; j++)&#123;</span><br><span class="line">                fa[node][j] = fa[fa[node][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            from = <span class="built_in">getk</span>(top - <span class="number">1</span>, val);</span><br><span class="line">            root[top] = root[from];</span><br><span class="line">            depth[top] = depth[from];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">                fa[top][j] = fa[from][j];</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">            top -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; tree[root[top - <span class="number">1</span>]].val &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//O(q)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tm</span><span class="params">(N + <span class="number">2</span>, N + <span class="number">1</span>)</span></span>;  <span class="comment">//记录每个值得最早出现得位置</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">con</span><span class="params">(N + <span class="number">2</span>, <span class="number">0</span>)</span></span>;     <span class="comment">//记录位置i的数是否产生了贡献</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ref</span><span class="params">(N + <span class="number">2</span>, <span class="number">0</span>)</span></span>;     <span class="comment">//记录位置i的之前的数是什么</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(N + <span class="number">2</span>, <span class="number">0</span>)</span></span>;     <span class="comment">//记录此时长度为i的序列的答案</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save0</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//for tm[val]</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save1</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//for tm[ref[len]]</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save2</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//fot ref</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">save3</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//for ans</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        std::cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            stk[top] = val;</span><br><span class="line">            len = len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            save1[top] = tm[ref[len]];</span><br><span class="line">            save0[top] = tm[val];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tm[ref[len]] == len)&#123;</span><br><span class="line">                con[len] = <span class="literal">false</span>;</span><br><span class="line">                tm[ref[len]] = <span class="number">0</span>;   <span class="comment">//将之前这个位置的最小出现位重置，这里不用考虑下一个相同元素，要么添加覆盖，要么回退</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tm[val] == <span class="number">0</span> || tm[val] &gt;= len)&#123;</span><br><span class="line">                <span class="comment">//取消远处标记的标记的贡献</span></span><br><span class="line">                con[tm[val]] = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//重置最小的元素出现位置</span></span><br><span class="line">                tm[val] = len;</span><br><span class="line">                con[len] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            save2[top] = ref[len];</span><br><span class="line">            ref[len] = val;</span><br><span class="line"></span><br><span class="line">            save3[top] = ans[len];</span><br><span class="line">            ans[len] = ans[len - <span class="number">1</span>] + con[len];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            top += <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            std::cin &gt;&gt; val;</span><br><span class="line">            len = len - val;</span><br><span class="line">            stk[top] = -val;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk[top] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans[len] = save3[top];</span><br><span class="line">                ref[len] = save2[top];</span><br><span class="line">                <span class="keyword">if</span>(save0[top] == <span class="number">0</span> || save0[top] &gt;= len)&#123;</span><br><span class="line">                    con[len] = <span class="literal">false</span>;</span><br><span class="line">                    tm[stk[top]] = save0[top];</span><br><span class="line">                    con[tm[stk[top]]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(save1[top] == len)&#123;</span><br><span class="line">                    con[len] = <span class="literal">true</span>;</span><br><span class="line">                    tm[save2[top]] = len;</span><br><span class="line">                &#125;</span><br><span class="line">                len -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len -= stk[top];</span><br><span class="line">            &#125;</span><br><span class="line">            top -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; ans[len] &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; i &lt;&lt; space &lt;&lt; len &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>cf2600</tag>
        <tag>可持久化线段树(主席树)</tag>
      </tags>
  </entry>
  <entry>
    <title>2024昆明区域赛 B. Brackets 题解</title>
    <url>/2025/08/31/2024%E6%98%86%E6%98%8E%E5%8C%BA%E5%9F%9F%E8%B5%9B-B-Brackets-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="B-Brackets"><a href="#B-Brackets" class="headerlink" title="B. Brackets"></a><a href="https://codeforces.com/gym/105588/problem/B">B. Brackets</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的括号序列，该括号序列包含4种括号(), [], {}, &lt;&gt;。一个合法的括号序列的定义是LxR，L和R是同种类的括号的左右括号，x是一个合法的括号序列，x &#x3D; y1y2，y1y2为两个合法的括号序列。题目还给我们m个子区间，我们需要计算这些子区间的括号序列进行两两匹配最多可以形成多少对合法的括号序列。(gym原题链接,复制粘贴前往 <a href="https://codeforces.com/gym/105588/problem/B">https://codeforces.com/gym/105588/problem/B</a>)</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们通过观察题目的合法括号序列的性质可以发现，对于一个合法的括号序列，如果我们将其拆分成两半，那么要么两半初始都是合法的，要么左半去掉已经匹配的可以缩成一系列的左括号，右半也是同理。考虑吧如何处理出每个区间是什么样的情况，我们继续观察发现对于左半的情况我们可以直接使用括号栈来维护前缀种待匹配的左括号，在每个右端点时考虑区间是否可以作为左半边，当出现无法匹配的位置时我们需要清空栈并且标记1到i（i为当前考虑的位置），这些位置均不可以作为区间的左端点。同时我们呢注意到对于产生匹配括号的区间[l, r]，[l + 1, r]都不可以作为左端点，因为这样一定会剩下一个右括号多出来。对于每个区间还有什么样的括号等待着匹配我们可以直接字符串哈希即可快速解决。</p>
<p>​	具体实现方面，我使用线段树来标记哪些点不可以作为左端点，然后对于括号栈同时维护下标，通过二分查找区间的待匹配括号哈希，同时动态维护括号栈的前缀哈希值。最后对于作为右半的括号，我们可以把括号序列和区间翻转，当作左半的情况再左一次。最后计算答案，注意已经匹配的区间不要数重复。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T val;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.val = a.val + b.val;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = a[pl];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        tree[p].val += (pr - pl + <span class="number">1</span>) * d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N = <span class="number">5e5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ull PP = <span class="number">131</span>;</span><br><span class="line">std::vector&lt;ull&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P.<span class="built_in">assign</span>(N + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        P[i] = P[i - <span class="number">1</span>] * PP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::cin &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot;@&quot;</span> + s;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">ask</span>(m + <span class="number">1</span>);</span><br><span class="line">    std::vector&lt;std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">pos</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; ask[i].ff &gt;&gt; ask[i].ss;</span><br><span class="line">        pos[ask[i].ss].<span class="built_in">push_back</span>(&#123;ask[i].ff, i&#125;);</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; s.substr(ask[i].ff, ask[i].ss - ask[i].ff + 1) &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::deque&lt;ull&gt; stkhash;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">char</span> c)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                || (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;&#123;&#x27;</span>) || (c == <span class="string">&#x27;&gt;&#x27;</span> &amp;&amp; stk.<span class="built_in">back</span>() == <span class="string">&#x27;&lt;&#x27;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::map&lt;ull, <span class="type">int</span>&gt; mp[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> work = [&amp;](<span class="type">int</span> mode)&#123;</span><br><span class="line">        ind.<span class="built_in">clear</span>();</span><br><span class="line">        stkhash.<span class="built_in">clear</span>();</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;&lt;&#x27;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">                ind.<span class="built_in">push_back</span>(i);</span><br><span class="line">                ull val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(stkhash.<span class="built_in">size</span>())</span><br><span class="line">                    val = stkhash.<span class="built_in">back</span>();</span><br><span class="line">                val = val * PP + s[i];</span><br><span class="line">                stkhash.<span class="built_in">push_back</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(s[i]))&#123;</span><br><span class="line">                    <span class="type">int</span> right = i;</span><br><span class="line">                    <span class="type">int</span> left = ind.<span class="built_in">back</span>();</span><br><span class="line">                    <span class="comment">//除了匹配括号的左括号下标，其余都不可以作为左端点</span></span><br><span class="line">                    seg.<span class="built_in">update</span>(left + <span class="number">1</span>, right, <span class="number">1</span>);</span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ind.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stkhash.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    seg.<span class="built_in">update</span>(<span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">                    ind.<span class="built_in">clear</span>();</span><br><span class="line">                    stkhash.<span class="built_in">clear</span>();</span><br><span class="line">                    stk.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[l, id] : pos[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(seg.<span class="built_in">query</span>(l, l).val == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> left = l;</span><br><span class="line">                    <span class="type">int</span> right = i;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> hasleft = std::<span class="built_in">lower_bound</span>(ind.<span class="built_in">begin</span>(), ind.<span class="built_in">end</span>(), left) - ind.<span class="built_in">begin</span>();</span><br><span class="line">                    <span class="type">int</span> hasright = std::<span class="built_in">upper_bound</span>(ind.<span class="built_in">begin</span>(), ind.<span class="built_in">end</span>(), right) - ind.<span class="built_in">begin</span>();</span><br><span class="line">                    hasright -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(hasright &gt;= hasleft)&#123;</span><br><span class="line">                        ull pre = (hasleft == <span class="number">0</span> ? <span class="number">0</span> : stkhash[hasleft - <span class="number">1</span>]);</span><br><span class="line">                        <span class="type">int</span> len = hasright - hasleft + <span class="number">1</span>;</span><br><span class="line">                        ull hash = stkhash[hasright] - pre * P[len];</span><br><span class="line">                        mp[mode][hash] += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(mode == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//此时一定是区间不包含任何待匹配段，mode == 0时计数</span></span><br><span class="line">                        zero += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">work</span>(<span class="number">0</span>);    <span class="comment">//mode 0 for left</span></span><br><span class="line">    pos = std::vector&lt;std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> r = n + <span class="number">1</span> - ask[i].ff;</span><br><span class="line">        <span class="type">int</span> l = n + <span class="number">1</span> - ask[i].ss;</span><br><span class="line">        pos[r].<span class="built_in">push_back</span>(&#123;l, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> last = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> need = n + <span class="number">1</span> - i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(last[need] == <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">            c = <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">        s[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">work</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>[hash, num] : mp[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="type">int</span> oth = mp[<span class="number">1</span>][hash];</span><br><span class="line">        ans += std::<span class="built_in">min</span>(num, oth);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += zero / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>区域赛</tag>
        <tag>2024昆明区域赛</tag>
        <tag>金牌题</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模拟实现</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1969E E. Unique Array题解</title>
    <url>/2025/08/23/CF1969E-E-Unique-Array%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Unique-Array"><a href="#E-Unique-Array" class="headerlink" title="E. Unique Array"></a><a href="https://codeforces.com/contest/1969/problem/E">E. Unique Array</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的数组，一个子段被称为独特的，当且仅当子段中存在一个元素只出现了一次。我们可以进行一种操作选择数组中的任意一个元素将其替换成任意数字。我们需要输出我们最少需要进行几次操作可以使得数组中的所有子段都是独特子段。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们容易想到一个O(n ^ 2 * lgn)的解法我们可以暴力的处理除所有不好的子段，根据我们操作的性质容易发现我们只要对子段中任意一个元素进行操作我们就一定可以使得包含这个元素的子段独特，于是问题转换成了一些区间，我们要选择最少数量的点，满足每个区间中至少包含一个节点。这是一个经典的贪心问题，我们直接按左端点或右端点排序，顺着贪心的取最边界的点即可。</p>
<p>​	我们发现实际上有效的区间数量实际上是不超过n个的，因为所有完全覆盖了某个区间的区间都是没有意义的，于是我们可以考虑处理出每个左端点对应的最小的不独特的区间，考虑如何处理出这些区间。我们可以对每个位置的数处理出其下一个相同的数的位置，我们枚举每个左端点，初始将所有的数的第一个进行区间[x, nxt[x] - 1] + 1的操作，这意味着从x到nxt[x] - 1被我们标记了，是不可以选择的右端点，因为其是独特的，我们找到（i，n）的最小的右端点，满足其元素为0即可，我们可以通过线段树维护最小值和最小值的下标来实现。处理出所有的区间后按照之前所述的贪心策略求最小点即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T pos;</span><br><span class="line">        T minn;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.minn = std::<span class="built_in">min</span>(a.minn, b.minn);</span><br><span class="line">        res.pos = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.minn == res.minn)</span><br><span class="line">            res.pos = std::<span class="built_in">min</span>(res.pos, a.pos);</span><br><span class="line">        <span class="keyword">if</span>(b.minn == res.minn)</span><br><span class="line">            res.pos = std::<span class="built_in">min</span>(res.pos, b.pos);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].minn = <span class="number">0</span>;</span><br><span class="line">            tree[p].pos = pl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        p.minn += d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i];</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(n + <span class="number">1</span>, n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        nxt[i] = last[cur[i]];</span><br><span class="line">        last[cur[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(last[i] != n + <span class="number">1</span>)&#123;</span><br><span class="line">            seg.<span class="built_in">update</span>(last[i], nxt[last[i]] - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = seg.<span class="built_in">query</span>(i, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.minn == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;i, p.pos&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">update</span>(i, nxt[i] - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nxt[i] != n + <span class="number">1</span>)</span><br><span class="line">            seg.<span class="built_in">update</span>(nxt[i], nxt[nxt[i]] - <span class="number">1</span>, <span class="number">1</span>);            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.ff &lt;= ls)&#123;</span><br><span class="line">            ls = std::<span class="built_in">min</span>(ls, p.ss);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">        ls = p.ss;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>cf2400</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1979E E. Manhattan Triangle题解</title>
    <url>/2025/08/23/CF1979E-E-Manhattan-Triangle%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Manhattan-Triangle"><a href="#E-Manhattan-Triangle" class="headerlink" title="E. Manhattan Triangle"></a><a href="https://codeforces.com/contest/1979/problem/E">E. Manhattan Triangle</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们n个二维平面上的不同的点，我们要挑出三个点使得这三个点构成一个等边三角形边长为d（保证d是偶数），注意这里等边的边长意义是在曼哈顿距离下的。输出挑选哪三个点，无解输出0，0，0。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们容易根据曼哈顿距离的定义发现对于某个点而言，距离它为d的点围成了一个菱形，同时因为三角形的性质，在曼哈顿意义下的等边三角形总有一条边是在斜率为1的线段上的（这里可以通过画图加以发现理解）。所以我们可以考虑枚举一个节点，然后考虑另外两个节点在斜率为1的线段上，我们x从小到大枚举，通过维护[x - d, x] 与 [x, x + d]的斜率为1或-1上的点来进行快速的判断是否存在我们当前点菱形四线段上间距为d的点对，这里只用考虑同一个线段上的点对即可，因为上面曼哈顿意义下等边的性质。具体维护我采用了map套set实现，标记线段归属的斜率和初相我使用x + y, x - y来进行标识。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cur</span>(n + <span class="number">1</span>);</span><br><span class="line">    std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; ind;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line">        ind[&#123;cur[i].ff, cur[i].ss&#125;] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangx_d;    <span class="comment">//记录从x-d到x的斜率为1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiax_d;    <span class="comment">//记录从x-d到x的斜率为-1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangaddd; <span class="comment">//记录从x到x + d的斜率为1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiaaddd;   <span class="comment">//记录从x到x + d的斜率为-1的线段,存在距离为d的点对的情况</span></span><br><span class="line">    </span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangx_dp;    <span class="comment">//记录从x-d到x的斜率为1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiax_dp;    <span class="comment">//记录从x-d到x的斜率为-1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; shangadddp; <span class="comment">//记录从x到x + d的斜率为1的线段,存在距离为d的点的情况</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::set&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; xiaadddp;   <span class="comment">//记录从x到x + d的斜率为-1的线段,存在距离为d的点的情况</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(cur.<span class="built_in">begin</span>() + <span class="number">1</span>, cur.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = cur[i].ff;</span><br><span class="line">        <span class="type">int</span> y = cur[i].ss;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右侧拓展</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt;= n &amp;&amp; cur[right].ff &lt;= x + d)&#123;</span><br><span class="line">            <span class="type">int</span> xn = cur[right].ff;</span><br><span class="line">            <span class="type">int</span> yn = cur[right].ss;</span><br><span class="line">            shangadddp[xn - yn].<span class="built_in">insert</span>(&#123;xn, yn&#125;);</span><br><span class="line">            xiaadddp[xn + yn].<span class="built_in">insert</span>(&#123;xn, yn&#125;);</span><br><span class="line">            <span class="keyword">if</span>(shangadddp[xn - yn].<span class="built_in">count</span>(&#123;xn -  d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                shangaddd[xn - yn].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(xiaadddp[xn + yn].<span class="built_in">count</span>(&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn - d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                xiaaddd[xn + yn].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            right += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左侧删除</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= i &amp;&amp; cur[left].ff &lt; x - d)&#123;</span><br><span class="line">            <span class="type">int</span> xn = cur[left].ff;</span><br><span class="line">            <span class="type">int</span> yn = cur[left].ss;</span><br><span class="line">            shangx_dp[xn - yn].<span class="built_in">erase</span>(&#123;xn, yn&#125;);</span><br><span class="line">            xiax_dp[xn + yn].<span class="built_in">erase</span>(&#123;xn, yn&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shangx_dp[xn - yn].<span class="built_in">count</span>(&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn + d / <span class="number">2</span>&#125;]);  </span><br><span class="line">                shangx_d[xn - yn].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(xiax_dp[xn + yn].<span class="built_in">count</span>(&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">                <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);</span><br><span class="line">                <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;xn, yn&#125;], ind[&#123;xn + d / <span class="number">2</span>, yn - d / <span class="number">2</span>&#125;]);  </span><br><span class="line">                xiax_d[xn + yn].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左侧拓展</span></span><br><span class="line">        shangx_dp[x - y].<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">        xiax_dp[x + y].<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(shangx_dp[x - y].<span class="built_in">count</span>(&#123;x -  d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            shangx_d[x - y].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xiax_dp[x + y].<span class="built_in">count</span>(&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x - d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            xiax_d[x + y].<span class="built_in">insert</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取是否存在匹配</span></span><br><span class="line">        <span class="type">int</span> needx = x + d;</span><br><span class="line">        <span class="type">int</span> needy = y;</span><br><span class="line">        <span class="keyword">if</span>(!shangaddd[needx - needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *shangaddd[needx - needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!xiaaddd[needx + needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *xiaaddd[needx + needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        needx = x - d;</span><br><span class="line">        needy = y;</span><br><span class="line">        <span class="keyword">if</span>(!shangx_d[needx - needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *shangx_d[needx - needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!xiax_d[needx + needy].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = *xiax_d[needx + needy].<span class="built_in">begin</span>();</span><br><span class="line">            std::cout &lt;&lt; ind[&#123;x, y&#125;] &lt;&lt; space &lt;&lt; p.ff &lt;&lt; space &lt;&lt; p.ss &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右侧删除</span></span><br><span class="line">        shangadddp[x - y].<span class="built_in">erase</span>(&#123;x, y&#125;);</span><br><span class="line">        xiaadddp[x + y].<span class="built_in">erase</span>(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">if</span>(shangadddp[x - y].<span class="built_in">count</span>(&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y + d / <span class="number">2</span>&#125;]);</span><br><span class="line">            shangaddd[x - y].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(xiaadddp[x + y].<span class="built_in">count</span>(&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;))&#123;</span><br><span class="line">            <span class="type">int</span> minn = std::<span class="built_in">min</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            <span class="type">int</span> maxn = std::<span class="built_in">max</span>(ind[&#123;x, y&#125;], ind[&#123;x + d / <span class="number">2</span>, y - d / <span class="number">2</span>&#125;]);</span><br><span class="line">            xiaaddd[x + y].<span class="built_in">erase</span>(&#123;minn, maxn&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">0</span> &lt;&lt; space &lt;&lt; <span class="number">0</span> &lt;&lt; space &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>模拟实现</tag>
        <tag>cf2400</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>arc203_d D - Insert XOR题解</title>
    <url>/2025/08/22/arc203-d-D-Insert-XOR%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D-Insert-XOR"><a href="#D-Insert-XOR" class="headerlink" title="D - Insert XOR"></a><a href="https://atcoder.jp/contests/arc203/tasks/arc203_d"><strong>D - Insert XOR</strong></a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的二进制字符串，我们要处理q次操作，每次操作给我们一个pos，我们会翻转s[pos]，我们每次操作后都要输出当前字符串的最小代价，操作是持久化的。一个二进制字符串的代价为需要的最小的初始字符串长度，使得我们可以通过对这个初始字符串进行若干次操作来得到当前字符串，我们可以进行的操作是选择两个相邻的字符元素，在其中间插入两个数异或的结果。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	我们考虑代价时从当前数组删减到最小的字符串长度来考虑会更容易，首先我们发现我们需要特判掉全部为1的情况，此时需要的初始字符串一定长度为n，然后剩余的情况我们可以进行的删减实际上就三种情况</p>
<pre><code>	1. 11 -&gt; 1 (要求当前字符串中存在0) 2. 000 -&gt; 00 (无要求) 3. 101 -&gt; 1 (要求当前字符串除这个对还存在0)
</code></pre>
<p>​    我们考虑吧维护每个元素对答案减小的贡献，则此时cur[i] &#x3D;&#x3D; 1 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 1, 此时位置i贡献为1，cur[i] &#x3D;&#x3D; 0 &amp;&amp; cur[i + 1] &#x3D;&#x3D; 0 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 0,此时位置i贡献为1，cur[i] &#x3D;&#x3D; 0 &amp;&amp; cur[i - 1] &#x3D;&#x3D; 1 &amp;&amp; cur[i + 1] &#x3D;&#x3D; 1,此时位置i的贡献为2，我们最后的答案就是n - 贡献和，注意答案为1时实际上要特判成2，因为我们不可能缩到1，再特判掉全1的情况即可，上面三种贡献实际上和三种删减情况一一对应。本题还有实现起来较为麻烦的线段树解法，我们直接用线段树维护区间的删减情况进行合并即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(n + <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">1</span>)</span><br><span class="line">            cnt1 += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">1</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">0</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[i + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[i] == <span class="number">0</span> &amp;&amp; cur[i - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[i + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> getans = [&amp;]()&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == n)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="number">2</span>, n - sum);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> del = [&amp;](<span class="type">int</span> pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span>)</span><br><span class="line">            cnt1 -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum -= <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; <span class="number">1</span> || pos &gt; n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span>)</span><br><span class="line">            cnt1 += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">1</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">            sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur[pos] == <span class="number">0</span> &amp;&amp; cur[pos - <span class="number">1</span>] == <span class="number">1</span> &amp;&amp; cur[pos + <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            sum += <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pos;</span><br><span class="line">        std::cin &gt;&gt; pos;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">del</span>(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">del</span>(pos);</span><br><span class="line">        <span class="built_in">del</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cur[pos] ^= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(pos);</span><br><span class="line">        <span class="built_in">add</span>(pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">getans</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>数据结构</tag>
        <tag>atcoder2400</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1934 D2. XOR Break — Game Version题解</title>
    <url>/2025/08/22/CF1934%20D2-XOR-Break-%E2%80%94-Game-Version%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D2-XOR-Break-—-Game-Version"><a href="#D2-XOR-Break-—-Game-Version" class="headerlink" title="D2. XOR Break — Game Version"></a><a href="https://codeforces.com/problemset/problem/1934/D2">D2. XOR Break — Game Version</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个初始数字n，我们要和对手进行博弈，我们可以选择先后手，我们与对手进行的游戏是这样的，当前数字初始为p，当前回合的选手需要构造两个数字p1，p2，满足（0 &lt; p1 &lt; p, 0 &lt; p2 &lt; p, p1 ^ p2 &#x3D;&#x3D; p)，若无法构造出p1，p2则当前回合玩家输，然后另一个人挑选其中任意一个数作为当前数字p，并开始它的回合。我们最多可以进行63次回合，需要保证必胜。初始数字n &lt; 1e18。交互题，系统给出对面的操作。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们可以发现一个关键的边界条件，当初始数字中为1的位为1时我们无法对其进行拆解，此时是必败态。我们考虑如何让对手到达这个状态或是这个状态由和转移过来。一个简单的必胜态是有两位数的情况，此时我们拆成两个1位为1的位的数则必胜。继续推广我们发现通过构造所有的为1的位为偶数时都是必胜态，奇数都是必败态，具体证明如下，对于一个偶数个位为1的数我们一定可以把其拆成两个为1的位为奇数的数，而对于为1的位为偶数的数我们无论怎么拆都是一奇数位为1，一个偶数位为1，所以我们只要继续挑选那个偶数位1的数进行拆分就可继续必胜。具体的拆分为了减少对面新增的1的位，我们直接把最高位1拆走，剩余的构成另外一个数即可，在题目要求下易证操作回合小于等于63。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcnt</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">63</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="built_in">getcnt</span>(n);</span><br><span class="line">    ll p1 = n;</span><br><span class="line">    ll p2 = n;</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> op = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="number">0</span> &amp;&amp; p2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        op += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getcnt</span>(p1) % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            std::<span class="built_in">swap</span>(p1, p2);</span><br><span class="line">        ll out1 = (<span class="number">1LL</span> &lt;&lt; std::__lg(p1));</span><br><span class="line">        ll out2 = (p1 ^ out1);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; out1 &lt;&lt; space &lt;&lt; out2 &lt;&lt; std::endl;</span><br><span class="line">        std::cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>cf2400</tag>
        <tag>博弈论</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1981D D. Turtle and Multiplication 题解</title>
    <url>/2025/08/21/CF1981D-D-Turtle-and-Multiplication-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="D-Turtle-and-Multiplication"><a href="#D-Turtle-and-Multiplication" class="headerlink" title="D. Turtle and Multiplication"></a><a href="https://codeforces.com/contest/1981/problem/D">D. Turtle and Multiplication</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个数字n，我们需要构造一个长度为n的数组，满足以下条件，数组中的所有元素属于[1, 3e5]，数组中没有两个相邻的元素的乘积相同，数组中不同的数的种类是长度为n下所有合法数组中最小的。输出任意一个符合条件的解。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先考虑如何在保证没有相邻元素的乘积相同的同时使得数组中不同种类的数的个数最小，我们发现我们选择所有不同的素数来构成数组一定是最优的，因为素数的性质保证了只要相邻两个元素的组成不同乘积就不同，不会出现2 * 6 &#x3D;&#x3D; 3 * 4这样的情况。x个数组可以组成 （x * (x + 1) ) &#x2F; 2种不同的组合。我们发现如果从图论的角度抽象这个问题，把不同的两两组合看作两个节点之间的边，那么问题就变成了从这张图中找出一个长度为n的欧拉路，注意到当need（需要的最少素数个数）为奇数时，图一定存在欧拉回路，need为偶数时图中不存在走完所有边的欧拉路，此时我们最少要删除（need - 2）&#x2F; 2条边才可以得到一个可以走完所有边的欧拉路，这也就是need个素数时可以产生的最大贡献。</p>
<p>​	通过素数筛法我们发现3e5范围内的素数是够用的，我们直接全部用素数构造数组即可，找到最小需要的素数数量，然后构建一个这几个素数的完全图，如果need为偶数时3 - 4 ，5 - 6， 7 - 8…这些边去掉，最后就可以保证欧拉路的存在。然后我们找出从1节点开始的欧拉路即可，此时一定可以包含图中所有边，我们输出前n - 1条边组成的节点即可得到长度为n的数组，且一定满足数组的需求定义。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; minp, primes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    minp.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    primes.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            minp[i] = i;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * p &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            minp[i * p] = p;</span><br><span class="line">            <span class="keyword">if</span> (p == minp[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e7</span>;  <span class="comment">//无向边需要开两倍</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> nex;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    e[cnt].from = u;</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    e[cnt].nex = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> need = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2e3</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> all = (i * (<span class="number">1</span> + i)) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            all -= (i - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(all + <span class="number">1</span> &gt;= n)&#123;</span><br><span class="line">            need = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> all = (need * (<span class="number">1</span> + need)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        all -= (need - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(<span class="number">1</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= need; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= need; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">1</span> &amp;&amp; i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; j == i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            edge.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            <span class="built_in">add</span>(i, j);</span><br><span class="line">            <span class="built_in">add</span>(j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">use</span><span class="params">(cnt + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> node) -&gt; <span class="type">void</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now = head[node]; now &gt; <span class="number">0</span>; now = head[node])&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(use[now])&#123;</span><br><span class="line">                head[node] = e[now].nex;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            use[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">                use[now ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            head[node] = e[now].nex;    <span class="comment">//删去遍历过的点</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dfs</span>(e[now].to);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ind = (t == <span class="number">1</span> ? now / <span class="number">2</span> : now - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span> &amp;&amp; now % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(ind);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(-ind);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(ind); <span class="comment">//注意对于有向图我们这里实际是找到的逆的路径，所以不用-ind</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(edge[ans[i]].ff);</span><br><span class="line">            res.<span class="built_in">push_back</span>(edge[ans[i]].ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(edge[-ans[i]].ss);</span><br><span class="line">            res.<span class="built_in">push_back</span>(edge[-ans[i]].ff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; primes[res[i]] &lt;&lt; sendl[i == n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= need; i++)</span><br><span class="line">        head[i] = <span class="number">0</span>;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>cf2400</tag>
        <tag>图论</tag>
        <tag>数论</tag>
        <tag>欧拉路/回路</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2063F2 F2. Counting Is Not Fun (Hard Version)题解</title>
    <url>/2025/08/21/CF2063F2-F2-Counting-Is-Not-Fun-Hard-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F2-Counting-Is-Not-Fun-Hard-Version"><a href="#F2-Counting-Is-Not-Fun-Hard-Version" class="headerlink" title="F2. Counting Is Not Fun (Hard Version)"></a><a href="https://codeforces.com/contest/2063/problem/F2">F2. Counting Is Not Fun (Hard Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​   题目给我们一个数字n，代表一个有着n个好对的括号序列，一个好对（i, j) (i &lt; j) 满足s[i] &#x3D;&#x3D; ‘(‘, s[j] &#x3D;&#x3D; ‘)’同时去掉i，j两个字符，区间内剩余的子串是一个合法的平衡括号字符串，可以证明对于一个长度位2 * n的括号序列一定有n个好对。题目依次给出n个好对，我们需要计算出前i个好对确定的情况下有多少种符号要求的合法括号字符串（i从0到n）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	与easy版本不同的是hard版的数据到达了3e5，首先我们easy版计算长度为x的合法括号序列的复杂度我们就无法接受，考虑如何快速计算，这实际上就是卡特兰数，我们的平衡度总是大于等于0，最后等于0，相当于不穿过y &#x3D; x，走到（x &#x2F; 2， x &#x2F; 2），我们可以世界使用卡特兰数的组合数学公式来快速计算。</p>
<p>​	接着考虑如何计算每个前缀好对的可能的括号序列数，注意到easy版我们对每个都进行了重新计算，这实际上没有必要，因为我们新加入一个好对只会影响最小的覆盖其的好对，重新计算它的贡献，然后乘上新加入的好对的贡献即可。要知道最小覆盖其的好对我们可以使用一个线段树维护覆盖某个点的长度最小的对的序号即可，这实际上相当于线段树维护最小值。知道某个好对还没被覆盖的点的个数我们可以使用令一个线段树维护区间最小值和这个区间最小值的个数即可，考虑某个好对，覆盖其的好对一定不会计算到其中，之后其中的好对非区间最小值的一定被覆盖了，而区间最小值一定没有被覆盖。我们重新计算新加入好对及覆盖其的好对的贡献即可。</p>
<p>​	本题实际上有一个更为简单的实现，倒着求答案，看作删除一个好对，这相当于把删除的好对和最小覆盖其的好对合并到了一起，抽象成图论可以看作缩点，其覆盖的子好对顺着转移过去即可，使用并查集维护节点，同时维护某个好对覆盖的子对长度和即可简单实现计算。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>; <span class="comment">//注意这里要多开点</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line">ll fact[N + <span class="number">1</span>],infact[N + <span class="number">1</span>];   <span class="comment">//  阶乘和阶乘的逆元</span></span><br><span class="line"><span class="comment">//取模版本快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll k, ll m)</span></span>&#123;   <span class="comment">//求a^k mod m</span></span><br><span class="line">    a %= m;</span><br><span class="line">    ll res = <span class="number">1</span> % m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * a % m;<span class="comment">//指数k为1的位乘上a^(1&lt;&lt;x)mod m</span></span><br><span class="line">        a = a * a % m;<span class="comment">//每一项是前一项的平方模m</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n = N)</span></span>&#123; <span class="comment">// 预处理阶乘取模的余数和阶乘取模余数的逆元</span></span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    infact[N] = <span class="built_in">qmi</span>(fact[N], mod - <span class="number">2</span>, mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        infact[i] = infact[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组合数A和C</span></span><br><span class="line"><span class="comment">//C(a, b) = !a / !(a - b) * !(b)    //a个里挑b个</span></span><br><span class="line"><span class="comment">//A(a, b) = !a / !(a - b)</span></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fact[a] * infact[a-b] % mod * infact[b] % mod;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> fact[a] * infact[a-b] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求逆元</span></span><br><span class="line"><span class="function">ll <span class="title">contary</span><span class="params">(ll now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qmi</span>(now, mod - <span class="number">2</span>, mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力计算组合数C</span></span><br><span class="line"><span class="function">ll <span class="title">burteC</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; k || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) ret = ret * (m - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) ret = ret * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getCn</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">C</span>(<span class="number">2</span> * n, n) - <span class="built_in">C</span>(<span class="number">2</span> * n, n - <span class="number">1</span>) + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T minn;</span><br><span class="line">        T val;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        res.minn = std::<span class="built_in">min</span>(a.minn, b.minn);</span><br><span class="line">        <span class="keyword">if</span>(a.minn == res.minn)</span><br><span class="line">            res.val += a.val;</span><br><span class="line">        <span class="keyword">if</span>(b.minn == res.minn)</span><br><span class="line">            res.val += b.val;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = <span class="number">1</span>;</span><br><span class="line">            tree[p].minn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        p.minn += d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        tag[p] += d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">0</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>((n + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>((n + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTreeInd</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        T minind;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;node&gt; tree;</span><br><span class="line">    std::vector&lt;T&gt; tag;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">merge</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">node</span>();</span><br><span class="line">        <span class="keyword">if</span>(cur[a.minind].ss - cur[a.minind].ff &lt;= cur[b.minind].ss - cur[b.minind].ff)</span><br><span class="line">            res = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res = b;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        tree[p] = <span class="built_in">merge</span>(tree[<span class="built_in">ls</span>(p)], tree[<span class="built_in">rs</span>(p)]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl == pr)&#123;</span><br><span class="line">            tree[p] = <span class="built_in">node</span>();</span><br><span class="line">            tree[p].val = a[pl];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(node&amp; p, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[p.minind].ss - cur[p.minind].ff &gt;= cur[d].ss - cur[d].ff)</span><br><span class="line">            p.minind = d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur[tag[p]].ss - cur[tag[p]].ff &gt;= cur[d].ss - cur[d].ff)</span><br><span class="line">            tag[p] = d;</span><br><span class="line">        <span class="built_in">add</span>(tree[p], d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag[p])&#123;</span><br><span class="line">            <span class="type">int</span> mid = (pr + pl) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);</span><br><span class="line">            <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">            tag[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)&#123;</span><br><span class="line">            <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);</span><br><span class="line">        <span class="built_in">push_up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= pl &amp;&amp; pr &lt;= R)</span><br><span class="line">            <span class="keyword">return</span> tree[p];</span><br><span class="line">        <span class="built_in">push_down</span>(p, pl, pr);</span><br><span class="line">        <span class="type">int</span> mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid &amp;&amp; R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid), <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr));</span><br><span class="line">        <span class="keyword">if</span>(L &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);</span><br><span class="line">        <span class="keyword">if</span>(R &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, T d)</span></span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTreeInd</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SegmentTreeInd</span>(std::vector&lt;T&gt; cur)&#123;</span><br><span class="line">        <span class="comment">//cur 是 1序列</span></span><br><span class="line">        <span class="type">int</span> len = cur.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        n = len;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="built_in">node</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        a = cur;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    cur.<span class="built_in">assign</span>(n + <span class="number">1</span>, std::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;());</span><br><span class="line">    cur[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">2</span> * n + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line">    std::vector&lt;ll&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="built_in">getCn</span>(n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> seg = <span class="built_in">SegmentTree</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> segid = <span class="built_in">SegmentTreeInd</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="built_in">getCn</span>(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ll in = seg.<span class="built_in">query</span>(cur[i].ff, cur[i].ss).val;</span><br><span class="line">        ll need = (in - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        ans = ans * <span class="built_in">getCn</span>(need) % mod;</span><br><span class="line"></span><br><span class="line">        ll fa = segid.<span class="built_in">query</span>(cur[i].ff, cur[i].ff).minind;</span><br><span class="line">        </span><br><span class="line">        ll infa = seg.<span class="built_in">query</span>(cur[fa].ff, cur[fa].ss).val;</span><br><span class="line"></span><br><span class="line">        ll needfa = (infa - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        ll con = <span class="built_in">getCn</span>(needfa);</span><br><span class="line">        ans = ans * <span class="built_in">qmi</span>(con, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line"></span><br><span class="line">        seg.<span class="built_in">update</span>(cur[i].ff, cur[i].ss, <span class="number">1</span>);</span><br><span class="line">        infa = seg.<span class="built_in">query</span>(cur[fa].ff, cur[fa].ss).val;</span><br><span class="line">        needfa = (infa - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        con = <span class="built_in">getCn</span>(needfa);</span><br><span class="line">        ans = ans * con % mod;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">        segid.<span class="built_in">update</span>(cur[i].ff, cur[i].ss, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; res[i] &lt;&lt; sendl[i == res.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模拟实现</tag>
        <tag>图论</tag>
        <tag>cf2700</tag>
        <tag>组合数学</tag>
        <tag>并查集</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2063F1 F1. Counting Is Not Fun (Easy Version)题解</title>
    <url>/2025/08/21/CF2063F1-F1-Counting-Is-Not-Fun-Easy-Version-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="F1-Counting-Is-Not-Fun-Easy-Version"><a href="#F1-Counting-Is-Not-Fun-Easy-Version" class="headerlink" title="F1. Counting Is Not Fun (Easy Version)"></a><a href="https://codeforces.com/contest/2063/problem/F1">F1. Counting Is Not Fun (Easy Version)</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个数字n，代表一个有着n个好对的括号序列，一个好对（i, j) (i &lt; j) 满足s[i] &#x3D;&#x3D; ‘(‘, s[j] &#x3D;&#x3D; ‘)’同时去掉i，j两个字符，区间内剩余的子串是一个合法的平衡括号字符串，可以证明对于一个长度位2 * n的括号序列一定有n个好对。题目依次给出n个好对，我们需要计算出前i个好对确定的情况下有多少种符号要求的合法括号字符串（i从0到n）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们根据题目的定义我们发现对于一个好对[l, r]其中l - 1， r - 1可以填任何合法的括号序列，所以我们需要预处理出长度x时的合法括号序列数，这可以通过dp[len] [diff]来n ^ 2的dp处理出来，状态表示长度为len时平衡度为diff的括号序列数量。然后考虑如何根据确定了的好对来计算可能的括号序列种类。我们发现一个好对就可以把其包含区间的种类给算出来，并且按照定义好对不会相交，只有可能包含，包含时我们可以用来填的空要是还没有确定的，也就是去掉包含的好对长度，于是对于前i个，我们可以通过维护左端点第一关键，右端点第二关键，有序的好对前缀，来O（n）的计算出每个好对还可以填写的空，结合dp[len] [0]相乘计数即可，最后乘上剩余所有没填的空的贡献即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> N = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span> * N + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = (<span class="number">1LL</span> * dp[i][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; N)</span><br><span class="line">                dp[i][j] = (<span class="number">1LL</span> * dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + dp[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">cur</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; cur[i].ff &gt;&gt; cur[i].ss;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;ll&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(dp[<span class="number">2</span> * n][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">occur</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    cur[<span class="number">0</span>].ff = <span class="number">0</span>;</span><br><span class="line">    cur[<span class="number">0</span>].ss = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ind = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur[qu[j]].ff &lt;= cur[i].ff || (cur[qu[j]].ff == cur[i].ff &amp;&amp; cur[qu[j]].ss &lt;= cur[i].ss))&#123;</span><br><span class="line">                ind = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//std::cerr &lt;&lt; i &lt;&lt; space &lt;&lt; ind &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; now;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= ind; j++)</span><br><span class="line">            now.<span class="built_in">push_back</span>(qu[j]);</span><br><span class="line">        now.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = ind + <span class="number">1</span>; j &lt; qu.<span class="built_in">size</span>(); j++)</span><br><span class="line">            now.<span class="built_in">push_back</span>(qu[j]);</span><br><span class="line">        qu = now;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// for(int j = 0; j &lt; qu.size(); j++)</span></span><br><span class="line">        <span class="comment">//     std::cerr &lt;&lt; qu[j] &lt;&lt; sendl[j == qu.size() - 1];</span></span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            occur[j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ind : qu)&#123;</span><br><span class="line">            <span class="type">int</span> l = cur[ind].ff;</span><br><span class="line">            <span class="type">int</span> r = cur[ind].ss;</span><br><span class="line">            <span class="keyword">while</span>(cur[stk.<span class="built_in">top</span>()].ss &lt; r)</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            occur[stk.<span class="built_in">top</span>()] += r - l + <span class="number">1</span>;</span><br><span class="line">            stk.<span class="built_in">push</span>(ind);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ll ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            ll use = <span class="number">2</span> + occur[j];</span><br><span class="line">            ll last = (cur[j].ss - cur[j].ff + <span class="number">1</span>) - use;</span><br><span class="line">            ans = (ans * dp[last][<span class="number">0</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ll last = <span class="number">2</span> * n - occur[<span class="number">0</span>];</span><br><span class="line">        ans = (ans * dp[last][<span class="number">0</span>]) % mod;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        std::cout &lt;&lt; res[i] &lt;&lt; sendl[i == res.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模拟实现</tag>
        <tag>cf2400</tag>
        <tag>动态规划</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>李超线段树模板(class)</title>
    <url>/2025/08/07/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF-class/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ShadowDrunk</span></span><br><span class="line"><span class="comment">//李超线段树实际上是维护在二维坐标系上插入线段，同时查询x == d时y最大的线段是哪个以及对应的值的变式线段树</span></span><br><span class="line"><span class="comment">//我们发现一个线段可以看作作用域在[x0, x1]上的一次函数，我们维护函数即可</span></span><br><span class="line"><span class="comment">//我们给每个节点打上标记用于懒操作，每个标记都是一个完全覆盖当前区间的线段</span></span><br><span class="line"><span class="comment">//当我们插入一个线段时我们把它拆分到其包含的所有区间去考虑它的影响</span></span><br><span class="line"><span class="comment">//考虑当前插入线段对其覆盖区间的影响，将当前线段和之前标记线段在mid处更优秀的留做懒标记</span></span><br><span class="line"><span class="comment">//mid处更劣的线段看在两边是否和更优线段存在交点</span></span><br><span class="line"><span class="comment">//显然最多左边或右边，有且只有一边可能存在交点，我们把更劣的线段递归下传继续考虑</span></span><br><span class="line"><span class="comment">//在处理查询时我们类似于标记永久化的思想遍历包含的所有节点（包含路径中的节点），取所有节点标记的线段中最优的</span></span><br><span class="line"><span class="comment">//这是因为我们标记的线段一定是最优的或是最优的是其父亲节点中的标记，但还没有下传，我们遍历了所有路径节点，最优线段一定在其中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiSegTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//李超线段树</span></span><br><span class="line"><span class="comment">//该模板维护的是线段对应k点最大的y归属于哪个序号最小的线段</span></span><br><span class="line"><span class="comment">//若需要修改成y最小需要修改用pmin以及改change内部的比较逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改O(lgn * lgn), 查询O(lgn)</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//x轴值域[1, n]</span></span><br><span class="line">    <span class="type">int</span> m;  <span class="comment">//插入的线段的最大数量</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回x与y的大小关系，1则x大，0相等，-1则y大</span></span><br><span class="line">        <span class="keyword">if</span>(x - y &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y - x &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">        <span class="comment">//记录线段斜率和截距</span></span><br><span class="line">        <span class="type">double</span> k, b;</span><br><span class="line">        <span class="built_in">line</span>(<span class="type">double</span> _k, <span class="type">double</span> _b)&#123;</span><br><span class="line">            k = _k; b = _b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">line</span>()&#123;</span><br><span class="line">            k = <span class="number">0</span>; b = -inf;</span><br><span class="line">            <span class="comment">//b == inf; //维护y最小时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;line&gt; p;    <span class="comment">//记录插入的线段</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//内部线段的数量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tag; <span class="comment">//记录区间标记属于哪个线段, 每个标记都是一个线段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> id, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算id对应线段在x == d时的值</span></span><br><span class="line">        <span class="keyword">return</span>  p[id].b + p[id].k * d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="comment">//插入线段, (x0, y0), (x1, y1) 为线段两个端点</span></span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x0 == x1)&#123;</span><br><span class="line">            p[cnt].k = <span class="number">0</span>;</span><br><span class="line">            p[cnt].b = std::<span class="built_in">max</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p[cnt].k = <span class="number">1.0</span> * (y1 - y0) / (x1 - x0);</span><br><span class="line">            p[cnt].b = y0 - p[cnt].k * x0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> root, T pl, T pr, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改被完全覆盖的区间的标记</span></span><br><span class="line">        <span class="type">int</span> &amp;v = tag[root];</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bmid = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, mid), <span class="built_in">calc</span>(v, mid));</span><br><span class="line">        <span class="keyword">if</span>(bmid == <span class="number">1</span> || (!bmid &amp;&amp; u &lt; v))</span><br><span class="line">            std::<span class="built_in">swap</span>(u, v);    <span class="comment">//确保u线段在mid处小于等于v线段</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bl = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pl), <span class="built_in">calc</span>(v, pl));</span><br><span class="line">        <span class="type">int</span> br = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pr), <span class="built_in">calc</span>(v, pr));</span><br><span class="line">        <span class="comment">//判断那边的区间存在交点</span></span><br><span class="line">        <span class="keyword">if</span>(bl == <span class="number">1</span> || (!bl &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, u);</span><br><span class="line">        <span class="keyword">if</span>(br == <span class="number">1</span> || (!br &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, u);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面两个if最多只会触发一个这保证了修改的复杂度</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //y最小代码</span></span><br><span class="line"><span class="comment">            if(bmid == -1 || (!bmid &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                std::swap(u, v);    //确保u线段在mid处大于等于v线段</span></span><br><span class="line"><span class="comment">            if(bl == -1 || (!bl &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change(root &lt;&lt; 1, pl, mid, u);</span></span><br><span class="line"><span class="comment">            if(br == -1 || (!br &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change((root &lt;&lt; 1) | 1, mid + 1, pr, u);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> root, T pl, T pr, T l, T r, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= pl &amp;&amp; pr &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">change</span>(root, pl, pr, u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, l, r, u);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, l, r, u); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmax</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmin</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> root, T l, T r, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询x == d时的答案</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt; d || l &gt; d)</span><br><span class="line">            <span class="keyword">return</span> &#123;-inf, <span class="number">0</span>&#125;;  <span class="comment">//维护y最小 return &#123;inf, 0&#125;;</span></span><br><span class="line">        T mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="built_in">calc</span>(tag[root], d);</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> &#123;res, tag[root]&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, tag[root]&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(root &lt;&lt; <span class="number">1</span>, l, mid, d),</span><br><span class="line">        <span class="built_in">query</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, d)));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //维护y最小时使用</span></span><br><span class="line"><span class="comment">            return pmin(&#123;res, s[root]&#125;, pmin(query(root &lt;&lt; 1, l, mid, d),</span></span><br><span class="line"><span class="comment">            query((root &lt;&lt; 1) | 1, mid + 1, r, d)));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addline</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x0 &gt; x1)&#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(x0, x1);</span><br><span class="line">            std::<span class="built_in">swap</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(x0, y0, x1, y1);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x0, x1, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>(<span class="type">int</span> _n, <span class="type">int</span> _m)&#123;</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>()&#123;</span><br><span class="line">        n = <span class="number">5e5</span>, m = <span class="number">5e5</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛模板</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>CF2064E E. Mycraft Sand Sort题解</title>
    <url>/2025/08/04/CF2064E%20E.%20Mycraft%20Sand%20Sort%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="E-Mycraft-Sand-Sort"><a href="#E-Mycraft-Sand-Sort" class="headerlink" title="E. Mycraft Sand Sort"></a><a href="https://codeforces.com/problemset/problem/2064/E">E. Mycraft Sand Sort</a></h2><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的排列，代表n行沙子，其元素大小就是第i行沙子的长度。题目还给我们一个长度为n的数组，其数组元素的值代表第i行沙子的颜色。最终沙子会因重力而落下，我们要计算初始有多少种排列和颜色的组合可以使得最终沙子落下来的效果与给定的一样，注意对998244353取模。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们通过观察发现本题的一个重要性质，数组的颜色数组是不会发生改变的，因为每一行的沙子的长度都大于等于1。所以第一格的元素的颜色就把整个数组的颜色给定了下来。并且长度为i的沙子是什么颜色也不会改变，所以方案数会增多就来源于同色的沙子之间的交换。我们发现对于颜色相同的第x行和第y行沙子可以交换的条件是沙子x和y之间不存在比其长度最小值大的异色沙子行，我们可以使用并查集和链表，从长度最小的沙子行开始考虑交换维护这个过程计算答案。</p>
<p>​	注意这里有一个误区，用并查集从小到大合并之后阶乘计算贡献是错误的，其并不可以保证我们的交换条件合法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">len</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; len[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; col[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> dsu = <span class="built_in">DSU</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">R</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[i] == col[i - <span class="number">1</span>])</span><br><span class="line">            dsu.<span class="built_in">merge</span>(i, i - <span class="number">1</span>);</span><br><span class="line">        L[i] = i - <span class="number">1</span>;</span><br><span class="line">        R[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">op</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        op[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(op.<span class="built_in">begin</span>(), op.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> len[a] &lt; len[b];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos : op)&#123;</span><br><span class="line"></span><br><span class="line">        ans = (ans * dsu.<span class="built_in">size</span>(pos)) % mod;</span><br><span class="line">        dsu.siz[dsu.<span class="built_in">find</span>(pos)] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dsu.<span class="built_in">size</span>(pos) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(col[L[pos]] == col[R[pos]] &amp;&amp; col[R[pos]] != <span class="number">0</span>)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(L[pos], R[pos]);</span><br><span class="line"></span><br><span class="line">        R[L[pos]] = R[pos];</span><br><span class="line">        L[R[pos]] = L[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>cf2400</tag>
      </tags>
  </entry>
</search>
