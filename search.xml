<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>这是一篇新新的文章</title>
    <url>/2025/08/04/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%96%B0%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<div class="video-container">
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113969272459949&bvid=BV1mCNLe4EpQ&cid=28285733231&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
</div>

<style>
.video-container {
    position: relative;
    width: 100%;
    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */
}

.video-container iframe {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
</style>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/08/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>李超线段树模板(class)</title>
    <url>/2025/08/07/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF-class/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ShadowDrunk</span></span><br><span class="line"><span class="comment">//李超线段树实际上是维护在二维坐标系上插入线段，同时查询x == d时y最大的线段是哪个以及对应的值的变式线段树</span></span><br><span class="line"><span class="comment">//我们发现一个线段可以看作作用域在[x0, x1]上的一次函数，我们维护函数即可</span></span><br><span class="line"><span class="comment">//我们给每个节点打上标记用于懒操作，每个标记都是一个完全覆盖当前区间的线段</span></span><br><span class="line"><span class="comment">//当我们插入一个线段时我们把它拆分到其包含的所有区间去考虑它的影响</span></span><br><span class="line"><span class="comment">//考虑当前插入线段对其覆盖区间的影响，将当前线段和之前标记线段在mid处更优秀的留做懒标记</span></span><br><span class="line"><span class="comment">//mid处更劣的线段看在两边是否和更优线段存在交点</span></span><br><span class="line"><span class="comment">//显然最多左边或右边，有且只有一边可能存在交点，我们把更劣的线段递归下传继续考虑</span></span><br><span class="line"><span class="comment">//在处理查询时我们类似于标记永久化的思想遍历包含的所有节点（包含路径中的节点），取所有节点标记的线段中最优的</span></span><br><span class="line"><span class="comment">//这是因为我们标记的线段一定是最优的或是最优的是其父亲节点中的标记，但还没有下传，我们遍历了所有路径节点，最优线段一定在其中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LiSegTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//李超线段树</span></span><br><span class="line"><span class="comment">//该模板维护的是线段对应k点最大的y归属于哪个序号最小的线段</span></span><br><span class="line"><span class="comment">//若需要修改成y最小需要修改用pmin以及改change内部的比较逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改O(lgn * lgn), 查询O(lgn)</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//x轴值域[1, n]</span></span><br><span class="line">    <span class="type">int</span> m;  <span class="comment">//插入的线段的最大数量</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回x与y的大小关系，1则x大，0相等，-1则y大</span></span><br><span class="line">        <span class="keyword">if</span>(x - y &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y - x &gt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">        <span class="comment">//记录线段斜率和截距</span></span><br><span class="line">        <span class="type">double</span> k, b;</span><br><span class="line">        <span class="built_in">line</span>(<span class="type">double</span> _k, <span class="type">double</span> _b)&#123;</span><br><span class="line">            k = _k; b = _b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">line</span>()&#123;</span><br><span class="line">            k = <span class="number">0</span>; b = -inf;</span><br><span class="line">            <span class="comment">//b == inf; //维护y最小时</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;line&gt; p;    <span class="comment">//记录插入的线段</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//内部线段的数量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tag; <span class="comment">//记录区间标记属于哪个线段, 每个标记都是一个线段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> id, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算id对应线段在x == d时的值</span></span><br><span class="line">        <span class="keyword">return</span>  p[id].b + p[id].k * d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="comment">//插入线段, (x0, y0), (x1, y1) 为线段两个端点</span></span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x0 == x1)&#123;</span><br><span class="line">            p[cnt].k = <span class="number">0</span>;</span><br><span class="line">            p[cnt].b = std::<span class="built_in">max</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p[cnt].k = <span class="number">1.0</span> * (y1 - y0) / (x1 - x0);</span><br><span class="line">            p[cnt].b = y0 - p[cnt].k * x0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> root, T pl, T pr, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改被完全覆盖的区间的标记</span></span><br><span class="line">        <span class="type">int</span> &amp;v = tag[root];</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> bmid = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, mid), <span class="built_in">calc</span>(v, mid));</span><br><span class="line">        <span class="keyword">if</span>(bmid == <span class="number">1</span> || (!bmid &amp;&amp; u &lt; v))</span><br><span class="line">            std::<span class="built_in">swap</span>(u, v);    <span class="comment">//确保u线段在mid处小于等于v线段</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bl = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pl), <span class="built_in">calc</span>(v, pl));</span><br><span class="line">        <span class="type">int</span> br = <span class="built_in">cmp</span>(<span class="built_in">calc</span>(u, pr), <span class="built_in">calc</span>(v, pr));</span><br><span class="line">        <span class="comment">//判断那边的区间存在交点</span></span><br><span class="line">        <span class="keyword">if</span>(bl == <span class="number">1</span> || (!bl &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, u);</span><br><span class="line">        <span class="keyword">if</span>(br == <span class="number">1</span> || (!br &amp;&amp; u &lt; v))</span><br><span class="line">            <span class="built_in">change</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, u);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面两个if最多只会触发一个这保证了修改的复杂度</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //y最小代码</span></span><br><span class="line"><span class="comment">            if(bmid == -1 || (!bmid &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                std::swap(u, v);    //确保u线段在mid处大于等于v线段</span></span><br><span class="line"><span class="comment">            if(bl == -1 || (!bl &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change(root &lt;&lt; 1, pl, mid, u);</span></span><br><span class="line"><span class="comment">            if(br == -1 || (!br &amp;&amp; u &lt; v))</span></span><br><span class="line"><span class="comment">                change((root &lt;&lt; 1) | 1, mid + 1, pr, u);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> root, T pl, T pr, T l, T r, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= pl &amp;&amp; pr &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">change</span>(root, pl, pr, u);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">            <span class="built_in">update</span>(root &lt;&lt; <span class="number">1</span>, pl, mid, l, r, u);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid)</span><br><span class="line">            <span class="built_in">update</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, pr, l, r, u); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmax</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">pmin</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; x, std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">        <span class="comment">//ff for val, ss for id</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.ff, y.ff) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">return</span> (x.ss &lt; y.ss ? x : y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> root, T l, T r, T d)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询x == d时的答案</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt; d || l &gt; d)</span><br><span class="line">            <span class="keyword">return</span> &#123;-inf, <span class="number">0</span>&#125;;  <span class="comment">//维护y最小 return &#123;inf, 0&#125;;</span></span><br><span class="line">        T mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="built_in">calc</span>(tag[root], d);</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> &#123;res, tag[root]&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pmax</span>(&#123;res, tag[root]&#125;, <span class="built_in">pmax</span>(<span class="built_in">query</span>(root &lt;&lt; <span class="number">1</span>, l, mid, d),</span><br><span class="line">        <span class="built_in">query</span>((root &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, d)));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //维护y最小时使用</span></span><br><span class="line"><span class="comment">            return pmin(&#123;res, s[root]&#125;, pmin(query(root &lt;&lt; 1, l, mid, d),</span></span><br><span class="line"><span class="comment">            query((root &lt;&lt; 1) | 1, mid + 1, r, d)));</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addline</span><span class="params">(T x0, T y0, T x1, T y1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x0 &gt; x1)&#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(x0, x1);</span><br><span class="line">            std::<span class="built_in">swap</span>(y0, y1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(x0, y0, x1, y1);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x0, x1, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(T d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>(<span class="type">int</span> _n, <span class="type">int</span> _m)&#123;</span><br><span class="line">        n = _n, m = _m;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LiSegTree</span>()&#123;</span><br><span class="line">        n = <span class="number">5e5</span>, m = <span class="number">5e5</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        tag.<span class="built_in">assign</span>(n &lt;&lt; <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(m + <span class="number">1</span>, <span class="built_in">line</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法竞赛模板</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇新的博文</title>
    <url>/2025/08/04/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84%E5%8D%9A%E6%96%87/</url>
    <content><![CDATA[<h2 id="E-Mycraft-Sand-Sort"><a href="#E-Mycraft-Sand-Sort" class="headerlink" title="E. Mycraft Sand Sort"></a><a href="https://codeforces.com/problemset/problem/2064/E">E. Mycraft Sand Sort</a></h2><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250225025237766.png" alt="image-20250225025237766" style="zoom:67%;" />

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250225025258255.png" alt="image-20250225025258255" style="zoom:67%;" />

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250225025316494.png" alt="image-20250225025316494" style="zoom:67%;" />

<h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>​	题目给我们一个长度为n的排列，代表n行沙子，其元素大小就是第i行沙子的长度。题目还给我们一个长度为n的数组，其数组元素的值代表第i行沙子的颜色。最终沙子会因重力而落下，我们要计算初始有多少种排列和颜色的组合可以使得最终沙子落下来的效果与给定的一样，注意对998244353取模。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​	首先我们通过观察发现本题的一个重要性质，数组的颜色数组是不会发生改变的，因为每一行的沙子的长度都大于等于1。所以第一格的元素的颜色就把整个数组的颜色给定了下来。并且长度为i的沙子是什么颜色也不会改变，所以方案数会增多就来源于同色的沙子之间的交换。我们发现对于颜色相同的第x行和第y行沙子可以交换的条件是沙子x和y之间不存在比其长度最小值大的异色沙子行，我们可以使用并查集和链表，从长度最小的沙子行开始考虑交换维护这个过程计算答案。</p>
<p>​	注意这里有一个误区，用并查集从小到大合并之后阶乘计算贡献是错误的，其并不可以保证我们的交换条件合法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">len</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; len[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        std::cin &gt;&gt; col[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> dsu = <span class="built_in">DSU</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">R</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(col[i] == col[i - <span class="number">1</span>])</span><br><span class="line">            dsu.<span class="built_in">merge</span>(i, i - <span class="number">1</span>);</span><br><span class="line">        L[i] = i - <span class="number">1</span>;</span><br><span class="line">        R[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">op</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        op[i] = i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(op.<span class="built_in">begin</span>(), op.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> len[a] &lt; len[b];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pos : op)&#123;</span><br><span class="line"></span><br><span class="line">        ans = (ans * dsu.<span class="built_in">size</span>(pos)) % mod;</span><br><span class="line">        dsu.siz[dsu.<span class="built_in">find</span>(pos)] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dsu.<span class="built_in">size</span>(pos) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(col[L[pos]] == col[R[pos]] &amp;&amp; col[R[pos]] != <span class="number">0</span>)</span><br><span class="line">                dsu.<span class="built_in">merge</span>(L[pos], R[pos]);</span><br><span class="line"></span><br><span class="line">        R[L[pos]] = R[pos];</span><br><span class="line">        L[R[pos]] = L[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>cf2400</tag>
      </tags>
  </entry>
</search>
